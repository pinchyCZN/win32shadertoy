const char *sample1=
"// Created by inigo quilez - iq/2013\r\n"
"// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n"
"\r\n"
"//stereo thanks to Croqueteer\r\n"
"//#define STEREO \r\n"
"\r\n"
"float hash( float n )\r\n"
"{\r\n"
"    return fract(sin(n)*43758.5453123);\r\n"
"}\r\n"
"\r\n"
"vec3 noised( in vec2 x )\r\n"
"{\r\n"
"    vec2 p = floor(x);\r\n"
"    vec2 f = fract(x);\r\n"
"\r\n"
"    vec2 u = f*f*(3.0-2.0*f);\r\n"
"\r\n"
"    float n = p.x + p.y*57.0;\r\n"
"\r\n"
"    float a = hash(n+  0.0);\r\n"
"    float b = hash(n+  1.0);\r\n"
"    float c = hash(n+ 57.0);\r\n"
"    float d = hash(n+ 58.0);\r\n"
"\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\r\n"
"\t\t\t\t30.0*f*f*(f*(f-2.0)+1.0)*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\r\n"
"\r\n"
"}\r\n"
"\r\n"
"float noise( in vec2 x )\r\n"
"{\r\n"
"    vec2 p = floor(x);\r\n"
"    vec2 f = fract(x);\r\n"
"\r\n"
"    f = f*f*(3.0-2.0*f);\r\n"
"\r\n"
"    float n = p.x + p.y*57.0;\r\n"
"\r\n"
"    float res = mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n"
"                    mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\r\n"
"\r\n"
"    return res;\r\n"
"}\r\n"
"\r\n"
"const mat2 m2 = mat2(1.6,-1.2,1.2,1.6);\r\n"
"\t\r\n"
"float fbm( vec2 p )\r\n"
"{\r\n"
"    float f = 0.0;\r\n"
"\r\n"
"    f += 0.5000*noise( p ); p = m2*p*2.02;\r\n"
"    f += 0.2500*noise( p ); p = m2*p*2.03;\r\n"
"    f += 0.1250*noise( p ); p = m2*p*2.01;\r\n"
"    f += 0.0625*noise( p );\r\n"
"\r\n"
"    return f/0.9375;\r\n"
"}\r\n"
"\r\n"
"float terrain( in vec2 x )\r\n"
"{\r\n"
"\tvec2  p = x*0.003;\r\n"
"    float a = 0.0;\r\n"
"    float b = 1.0;\r\n"
"\tvec2  d = vec2(0.0);\r\n"
"    for( int i=0; i<6; i++ )\r\n"
"    {\r\n"
"        vec3 n = noised(p);\r\n"
"        d += n.yz;\r\n"
"        a += b*n.x/(1.0+dot(d,d));\r\n"
"\t\tb *= 0.5;\r\n"
"        p = m2*p;\r\n"
"    }\r\n"
"\r\n"
"\treturn 140.0*a;\r\n"
"}\r\n"
"\r\n"
"float terrain2( in vec2 x )\r\n"
"{\r\n"
"\tvec2  p = x*0.003;\r\n"
"    float a = 0.0;\r\n"
"    float b = 1.0;\r\n"
"\tvec2  d = vec2(0.0);\r\n"
"    for( int i=0; i<14; i++ )\r\n"
"    {\r\n"
"        vec3 n = noised(p);\r\n"
"        d += n.yz;\r\n"
"        a += b*n.x/(1.0+dot(d,d));\r\n"
"\t\tb *= 0.5;\r\n"
"        p=m2*p;\r\n"
"    }\r\n"
"\r\n"
"\treturn 140.0*a;\r\n"
"}\r\n"
"\r\n"
"float terrain3( in vec2 x )\r\n"
"{\r\n"
"\tvec2  p = x*0.003;\r\n"
"    float a = 0.0;\r\n"
"    float b = 1.0;\r\n"
"\tvec2  d = vec2(0.0);\r\n"
"    for( int i=0; i<4; i++ )\r\n"
"    {\r\n"
"        vec3 n = noised(p);\r\n"
"        d += n.yz;\r\n"
"        a += b*n.x/(1.0+dot(d,d));\r\n"
"\t\tb *= 0.5;\r\n"
"        p = m2*p;\r\n"
"    }\r\n"
"\r\n"
"\treturn 140.0*a;\r\n"
"}\r\n"
"\r\n"
"float map( in vec3 p )\r\n"
"{\r\n"
"\tfloat h = terrain(p.xz);\r\n"
"    return p.y - h;\r\n"
"}\r\n"
"\r\n"
"float map2( in vec3 p )\r\n"
"{\r\n"
"\tfloat h = terrain2(p.xz);\r\n"
"    return p.y - h;\r\n"
"}\r\n"
"\r\n"
"float interesct( in vec3 ro, in vec3 rd )\r\n"
"{\r\n"
"    float h = 1.0;\r\n"
"    float t = 1.0;\r\n"
"\tfor( int i=0; i<128; i++ )\r\n"
"\t{\r\n"
"\t\tif( h<0.1 || t>2000.0 ) break;\r\n"
"\t\tt += 0.5*h*(1.0+0.0002*t);\r\n"
"\t\th = map( ro + t*rd );\r\n"
"\t}\r\n"
"\r\n"
"\tif( h>10.0 ) t = -1.0;\r\n"
"\treturn t;\r\n"
"}\r\n"
"\r\n"
"float sinteresct(in vec3 rO, in vec3 rD )\r\n"
"{\r\n"
"    float res = 1.0;\r\n"
"    float t = 0.0;\r\n"
"\tfor( int j=0; j<50; j++ )\r\n"
"\t{\r\n"
"        //if( t>1000.0 ) break;\r\n"
"\t    vec3 p = rO + t*rD;\r\n"
"\r\n"
"        float h = map( p );\r\n"
"\r\n"
"\t\tres = min( res, 16.0*h/t );\r\n"
"\t\tt += h;\r\n"
"\r\n"
"\t}\r\n"
"\r\n"
"\treturn clamp( res, 0.0, 1.0 );\r\n"
"}\r\n"
"\r\n"
"vec3 calcNormal( in vec3 pos, float t )\r\n"
"{\r\n"
"\tfloat e = 0.001;\r\n"
"\te = 0.001*t;\r\n"
"    vec3  eps = vec3(e,0.0,0.0);\r\n"
"    vec3 nor;\r\n"
"    nor.x = map2(pos+eps.xyy) - map2(pos-eps.xyy);\r\n"
"    nor.y = map2(pos+eps.yxy) - map2(pos-eps.yxy);\r\n"
"    nor.z = map2(pos+eps.yyx) - map2(pos-eps.yyx);\r\n"
"    return normalize(nor);\r\n"
"}\r\n"
"\r\n"
"vec3 camPath( float time )\r\n"
"{\r\n"
"    vec2 p = 600.0*vec2( cos(1.4+0.37*time), \r\n"
"                         cos(3.2+0.31*time) );\r\n"
"\r\n"
"\treturn vec3( p.x, 0.0, p.y );\r\n"
"}\r\n"
"\r\n"
"void main(void)\r\n"
"{\r\n"
"    vec2 xy = -1.0 + 2.0*gl_FragCoord.xy / iResolution.xy;\r\n"
"\r\n"
"\tvec2 s = xy*vec2(1.75,1.0);\r\n"
"\r\n"
"\t#ifdef STEREO\r\n"
"\tfloat isCyan = mod(gl_FragCoord.x + mod(gl_FragCoord.y,2.0),2.0);\r\n"
"    #endif\r\n"
"\t\r\n"
"    float time = iGlobalTime*.15 + 4.0*iMouse.x/iResolution.x;\r\n"
"\r\n"
"\tvec3 light1 = normalize( vec3(  0.4, 0.22,  0.6 ) );\r\n"
"\r\n"
"\r\n"
"\tvec3 ro = camPath( time );\r\n"
"\tvec3 ta = camPath( time + 3.0 );\r\n"
"\tro.y = terrain3( ro.xz ) + 11.0;\r\n"
"\tta.y = ro.y - 100.0;\r\n"
"\r\n"
"\tfloat cr = 0.2*cos(0.1*time);\r\n"
"\tvec3  cw = normalize(ta-ro);\r\n"
"\tvec3  cp = vec3(sin(cr), cos(cr),0.0);\r\n"
"\tvec3  cu = normalize( cross(cw,cp) );\r\n"
"\tvec3  cv = normalize( cross(cu,cw) );\r\n"
"\tvec3  rd = normalize( s.x*cu + s.y*cv + 1.5*cw );\r\n"
"\r\n"
"\t#ifdef STEREO\r\n"
"\tro += 2.0*cu*isCyan; // move camera to the right - the rd vector is still good\r\n"
"    #endif\r\n"
"\r\n"
"\tfloat sundot = clamp(dot(rd,light1),0.0,1.0);\r\n"
"\tvec3 col;\r\n"
"    float t = interesct( ro, rd );\r\n"
"    if( t<0.0 )\r\n"
"    {\r\n"
"\t\tcol = vec3(0.85,.95,1.0)*(1.0-0.5*rd.y);\r\n"
"\t\tcol += 0.25*vec3(1.0,0.8,0.4)*pow( sundot,12.0 );\r\n"
"\t\t\r\n"
"\t}\r\n"
"\telse\r\n"
"\t{\r\n"
"\t\tvec3 pos = ro + t*rd;\r\n"
"\r\n"
"        vec3 nor = calcNormal( pos, t );\r\n"
"\r\n"
"\t\tfloat r = noise( 7.0*pos.xz );\r\n"
"\r\n"
"        col = (r*0.25+0.75)*0.9*mix( vec3(0.08,0.05,0.03), vec3(0.13,0.10,0.08), clamp(terrain2( vec2(pos.x,pos.y*48.0))/200.0,0.0,1.0) );\r\n"
"\t\tcol = mix( col, 0.15*vec3(0.45,.23,0.04)*(0.50+0.50*r),smoothstep(0.70,0.9,nor.y) );\r\n"
"        col = mix( col, 0.10*vec3(0.30,.30,0.00)*(0.25+0.75*r),smoothstep(0.95,1.0,nor.y) );\r\n"
"  \t    col *= 0.9;\r\n"
"         // snow\r\n"
"\t\tfloat h = smoothstep(55.0,80.0,pos.y + 25.0*fbm(0.01*pos.xz) );\r\n"
"        float e = smoothstep(1.0-0.5*h,1.0-0.1*h,nor.y);\r\n"
"        float o = 0.3 + 0.7*smoothstep(0.0,0.1,nor.x+h*h);\r\n"
"        float s = h*e*o;\r\n"
"        col = mix( col, 0.35*vec3(0.62,0.65,0.7), smoothstep( 0.1, 0.9, s ) );\r\n"
"\r\n"
"         // lighting\t\t\r\n"
"        float amb = clamp(0.5+0.5*nor.y,0.0,1.0);\r\n"
"\t\tfloat dif = clamp( dot( light1, nor ), 0.0, 1.0 );\r\n"
"\t\tfloat bac = clamp( 0.2 + 0.8*dot( normalize( vec3(-light1.x, 0.0, light1.z ) ), nor ), 0.0, 1.0 );\r\n"
"\t\tfloat sh = 1.0; if( dif>=0.0001 ) sh = sinteresct(pos+light1*20.0,light1);\r\n"
"\t\t\r\n"
"\t\tvec3 lin  = vec3(0.0);\r\n"
"        lin += dif*vec3(8.00,5.50,3.00)*vec3( sh, sh*sh*0.5+0.5*sh, sh*sh*0.8+0.2*sh );\r\n"
"\t\tlin += amb*vec3(0.30,0.50,0.60);\r\n"
"        lin += bac*vec3(0.60,0.60,0.60);\r\n"
"\r\n"
"\t\tcol *= lin;\r\n"
"\t\t\r\n"
"\t\tfloat fo = 1.0-exp(-0.0007*t);\r\n"
"\t\tvec3 fco = vec3(0.55,0.65,0.75) + 0.6*vec3(1.0,0.8,0.5)*pow( sundot, 4.0 );\r\n"
"\t\tcol = mix( col, fco, fo );\r\n"
"\r\n"
"\t\tcol += 0.4*vec3(1.0,0.8,0.4)*pow( sundot, 8.0 )*(1.0-exp(-0.005*t));\r\n"
"\t}\r\n"
"\r\n"
"\t\r\n"
"\tcol = pow(col,vec3(0.45));\r\n"
"\r\n"
"\tcol = col*0.6 + 0.4*col*col*(3.0-2.0*col);\r\n"
"\t\r\n"
"\tvec2 uv = xy*0.5+0.5;\r\n"
"\tcol *= 0.7 + 0.3*pow(16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y),0.1);\r\n"
"\t\r\n"
"    #ifdef STEREO\t\r\n"
"    col *= vec3( isCyan, 1.0-isCyan, 1.0-isCyan );\t\r\n"
"\t#endif\r\n"
"\t\r\n"
"\tgl_FragColor=vec4(col,1.0);\r\n"
"}\r\n";

const char *sample2=
"float noise(vec3 p) //Thx to Las^Mercury\r\n"
"{\r\n"
"\tvec3 i = floor(p);\r\n"
"\tvec4 a = dot(i, vec3(1., 57., 21.)) + vec4(0., 57., 21., 78.);\r\n"
"\tvec3 f = cos((p-i)*acos(-1.))*(-.5)+.5;\r\n"
"\ta = mix(sin(cos(a)*a),sin(cos(1.+a)*(1.+a)), f.x);\r\n"
"\ta.xy = mix(a.xz, a.yw, f.y);\r\n"
"\treturn mix(a.x, a.y, f.z);\r\n"
"}\r\n"
"\r\n"
"float sphere(vec3 p, vec4 spr)\r\n"
"{\r\n"
"\treturn length(spr.xyz-p) - spr.w;\r\n"
"}\r\n"
"\r\n"
"float flame(vec3 p)\r\n"
"{\r\n"
"\tfloat d = sphere(p*vec3(1.,.5,1.), vec4(.0,-1.,.0,1.));\r\n"
"\treturn d + (noise(p+vec3(.0,iGlobalTime*2.,.0)) + noise(p*3.)*.5)*.25*(p.y) ;\r\n"
"}\r\n"
"\r\n"
"float scene(vec3 p)\r\n"
"{\r\n"
"\treturn min(100.-length(p) , abs(flame(p)) );\r\n"
"}\r\n"
"\r\n"
"vec4 raymarch(vec3 org, vec3 dir)\r\n"
"{\r\n"
"\tfloat d = 0.0, glow = 0.0, eps = 0.02;\r\n"
"\tvec3  p = org;\r\n"
"\tbool glowed = false;\r\n"
"\t\r\n"
"\tfor(int i=0; i<64; i++)\r\n"
"\t{\r\n"
"\t\td = scene(p) + eps;\r\n"
"\t\tp += d * dir;\r\n"
"\t\tif( d>eps )\r\n"
"\t\t{\r\n"
"\t\t\tif(flame(p) < .0)\r\n"
"\t\t\t\tglowed=true;\r\n"
"\t\t\tif(glowed)\r\n"
"       \t\t\tglow = float(i)/64.;\r\n"
"\t\t}\r\n"
"\t}\r\n"
"\treturn vec4(p,glow);\r\n"
"}\r\n"
"\r\n"
"void main()\r\n"
"{\r\n"
"\tvec2 v = -1.0 + 2.0 * gl_FragCoord.xy / iResolution.xy;\r\n"
"\tv.x *= iResolution.x/iResolution.y;\r\n"
"\t\r\n"
"\tvec3 org = vec3(0., -2., 4.);\r\n"
"\tvec3 dir = normalize(vec3(v.x*1.6, -v.y, -1.5));\r\n"
"\t\r\n"
"\tvec4 p = raymarch(org, dir);\r\n"
"\tfloat glow = p.w;\r\n"
"\t\r\n"
"\tvec4 col = mix(vec4(1.,.5,.1,1.), vec4(0.1,.5,1.,1.), p.y*.02+.4);\r\n"
"\t\r\n"
"\tgl_FragColor = mix(vec4(0.), col, pow(glow*2.,4.));\r\n"
"\t//gl_FragColor = mix(vec4(1.), mix(vec4(1.,.5,.1,1.),vec4(0.1,.5,1.,1.),p.y*.02+.4), pow(glow*2.,4.));\r\n"
"\r\n"
"}\r\n";

