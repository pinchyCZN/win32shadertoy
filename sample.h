const char *sample1=
"// Created by inigo quilez - iq/2013\r\n"
"// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n"
"\r\n"
"//stereo thanks to Croqueteer\r\n"
"//#define STEREO \r\n"
"\r\n"
"float hash( float n )\r\n"
"{\r\n"
"    return fract(sin(n)*43758.5453123);\r\n"
"}\r\n"
"\r\n"
"vec3 noised( in vec2 x )\r\n"
"{\r\n"
"    vec2 p = floor(x);\r\n"
"    vec2 f = fract(x);\r\n"
"\r\n"
"    vec2 u = f*f*(3.0-2.0*f);\r\n"
"\r\n"
"    float n = p.x + p.y*57.0;\r\n"
"\r\n"
"    float a = hash(n+  0.0);\r\n"
"    float b = hash(n+  1.0);\r\n"
"    float c = hash(n+ 57.0);\r\n"
"    float d = hash(n+ 58.0);\r\n"
"\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\r\n"
"\t\t\t\t30.0*f*f*(f*(f-2.0)+1.0)*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\r\n"
"\r\n"
"}\r\n"
"\r\n"
"float noise( in vec2 x )\r\n"
"{\r\n"
"    vec2 p = floor(x);\r\n"
"    vec2 f = fract(x);\r\n"
"\r\n"
"    f = f*f*(3.0-2.0*f);\r\n"
"\r\n"
"    float n = p.x + p.y*57.0;\r\n"
"\r\n"
"    float res = mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n"
"                    mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\r\n"
"\r\n"
"    return res;\r\n"
"}\r\n"
"\r\n"
"const mat2 m2 = mat2(1.6,-1.2,1.2,1.6);\r\n"
"\t\r\n"
"float fbm( vec2 p )\r\n"
"{\r\n"
"    float f = 0.0;\r\n"
"\r\n"
"    f += 0.5000*noise( p ); p = m2*p*2.02;\r\n"
"    f += 0.2500*noise( p ); p = m2*p*2.03;\r\n"
"    f += 0.1250*noise( p ); p = m2*p*2.01;\r\n"
"    f += 0.0625*noise( p );\r\n"
"\r\n"
"    return f/0.9375;\r\n"
"}\r\n"
"\r\n"
"float terrain( in vec2 x )\r\n"
"{\r\n"
"\tvec2  p = x*0.003;\r\n"
"    float a = 0.0;\r\n"
"    float b = 1.0;\r\n"
"\tvec2  d = vec2(0.0);\r\n"
"    for( int i=0; i<6; i++ )\r\n"
"    {\r\n"
"        vec3 n = noised(p);\r\n"
"        d += n.yz;\r\n"
"        a += b*n.x/(1.0+dot(d,d));\r\n"
"\t\tb *= 0.5;\r\n"
"        p = m2*p;\r\n"
"    }\r\n"
"\r\n"
"\treturn 140.0*a;\r\n"
"}\r\n"
"\r\n"
"float terrain2( in vec2 x )\r\n"
"{\r\n"
"\tvec2  p = x*0.003;\r\n"
"    float a = 0.0;\r\n"
"    float b = 1.0;\r\n"
"\tvec2  d = vec2(0.0);\r\n"
"    for( int i=0; i<14; i++ )\r\n"
"    {\r\n"
"        vec3 n = noised(p);\r\n"
"        d += n.yz;\r\n"
"        a += b*n.x/(1.0+dot(d,d));\r\n"
"\t\tb *= 0.5;\r\n"
"        p=m2*p;\r\n"
"    }\r\n"
"\r\n"
"\treturn 140.0*a;\r\n"
"}\r\n"
"\r\n"
"float terrain3( in vec2 x )\r\n"
"{\r\n"
"\tvec2  p = x*0.003;\r\n"
"    float a = 0.0;\r\n"
"    float b = 1.0;\r\n"
"\tvec2  d = vec2(0.0);\r\n"
"    for( int i=0; i<4; i++ )\r\n"
"    {\r\n"
"        vec3 n = noised(p);\r\n"
"        d += n.yz;\r\n"
"        a += b*n.x/(1.0+dot(d,d));\r\n"
"\t\tb *= 0.5;\r\n"
"        p = m2*p;\r\n"
"    }\r\n"
"\r\n"
"\treturn 140.0*a;\r\n"
"}\r\n"
"\r\n"
"float map( in vec3 p )\r\n"
"{\r\n"
"\tfloat h = terrain(p.xz);\r\n"
"    return p.y - h;\r\n"
"}\r\n"
"\r\n"
"float map2( in vec3 p )\r\n"
"{\r\n"
"\tfloat h = terrain2(p.xz);\r\n"
"    return p.y - h;\r\n"
"}\r\n"
"\r\n"
"float interesct( in vec3 ro, in vec3 rd )\r\n"
"{\r\n"
"    float h = 1.0;\r\n"
"    float t = 1.0;\r\n"
"\tfor( int i=0; i<128; i++ )\r\n"
"\t{\r\n"
"\t\tif( h<0.1 || t>2000.0 ) break;\r\n"
"\t\tt += 0.5*h*(1.0+0.0002*t);\r\n"
"\t\th = map( ro + t*rd );\r\n"
"\t}\r\n"
"\r\n"
"\tif( h>10.0 ) t = -1.0;\r\n"
"\treturn t;\r\n"
"}\r\n"
"\r\n"
"float sinteresct(in vec3 rO, in vec3 rD )\r\n"
"{\r\n"
"    float res = 1.0;\r\n"
"    float t = 0.0;\r\n"
"\tfor( int j=0; j<50; j++ )\r\n"
"\t{\r\n"
"        //if( t>1000.0 ) break;\r\n"
"\t    vec3 p = rO + t*rD;\r\n"
"\r\n"
"        float h = map( p );\r\n"
"\r\n"
"\t\tres = min( res, 16.0*h/t );\r\n"
"\t\tt += h;\r\n"
"\r\n"
"\t}\r\n"
"\r\n"
"\treturn clamp( res, 0.0, 1.0 );\r\n"
"}\r\n"
"\r\n"
"vec3 calcNormal( in vec3 pos, float t )\r\n"
"{\r\n"
"\tfloat e = 0.001;\r\n"
"\te = 0.001*t;\r\n"
"    vec3  eps = vec3(e,0.0,0.0);\r\n"
"    vec3 nor;\r\n"
"    nor.x = map2(pos+eps.xyy) - map2(pos-eps.xyy);\r\n"
"    nor.y = map2(pos+eps.yxy) - map2(pos-eps.yxy);\r\n"
"    nor.z = map2(pos+eps.yyx) - map2(pos-eps.yyx);\r\n"
"    return normalize(nor);\r\n"
"}\r\n"
"\r\n"
"vec3 camPath( float time )\r\n"
"{\r\n"
"    vec2 p = 600.0*vec2( cos(1.4+0.37*time), \r\n"
"                         cos(3.2+0.31*time) );\r\n"
"\r\n"
"\treturn vec3( p.x, 0.0, p.y );\r\n"
"}\r\n"
"\r\n"
"void main(void)\r\n"
"{\r\n"
"    vec2 xy = -1.0 + 2.0*gl_FragCoord.xy / iResolution.xy;\r\n"
"\r\n"
"\tvec2 s = xy*vec2(1.75,1.0);\r\n"
"\r\n"
"\t#ifdef STEREO\r\n"
"\tfloat isCyan = mod(gl_FragCoord.x + mod(gl_FragCoord.y,2.0),2.0);\r\n"
"    #endif\r\n"
"\t\r\n"
"    float time = iGlobalTime*.15 + 4.0*iMouse.x/iResolution.x;\r\n"
"\r\n"
"\tvec3 light1 = normalize( vec3(  0.4, 0.22,  0.6 ) );\r\n"
"\r\n"
"\r\n"
"\tvec3 ro = camPath( time );\r\n"
"\tvec3 ta = camPath( time + 3.0 );\r\n"
"\tro.y = terrain3( ro.xz ) + 11.0;\r\n"
"\tta.y = ro.y - 100.0;\r\n"
"\r\n"
"\tfloat cr = 0.2*cos(0.1*time);\r\n"
"\tvec3  cw = normalize(ta-ro);\r\n"
"\tvec3  cp = vec3(sin(cr), cos(cr),0.0);\r\n"
"\tvec3  cu = normalize( cross(cw,cp) );\r\n"
"\tvec3  cv = normalize( cross(cu,cw) );\r\n"
"\tvec3  rd = normalize( s.x*cu + s.y*cv + 1.5*cw );\r\n"
"\r\n"
"\t#ifdef STEREO\r\n"
"\tro += 2.0*cu*isCyan; // move camera to the right - the rd vector is still good\r\n"
"    #endif\r\n"
"\r\n"
"\tfloat sundot = clamp(dot(rd,light1),0.0,1.0);\r\n"
"\tvec3 col;\r\n"
"    float t = interesct( ro, rd );\r\n"
"    if( t<0.0 )\r\n"
"    {\r\n"
"\t\tcol = vec3(0.85,.95,1.0)*(1.0-0.5*rd.y);\r\n"
"\t\tcol += 0.25*vec3(1.0,0.8,0.4)*pow( sundot,12.0 );\r\n"
"\t\t\r\n"
"\t}\r\n"
"\telse\r\n"
"\t{\r\n"
"\t\tvec3 pos = ro + t*rd;\r\n"
"\r\n"
"        vec3 nor = calcNormal( pos, t );\r\n"
"\r\n"
"\t\tfloat r = noise( 7.0*pos.xz );\r\n"
"\r\n"
"        col = (r*0.25+0.75)*0.9*mix( vec3(0.08,0.05,0.03), vec3(0.13,0.10,0.08), clamp(terrain2( vec2(pos.x,pos.y*48.0))/200.0,0.0,1.0) );\r\n"
"\t\tcol = mix( col, 0.15*vec3(0.45,.23,0.04)*(0.50+0.50*r),smoothstep(0.70,0.9,nor.y) );\r\n"
"        col = mix( col, 0.10*vec3(0.30,.30,0.00)*(0.25+0.75*r),smoothstep(0.95,1.0,nor.y) );\r\n"
"  \t    col *= 0.9;\r\n"
"         // snow\r\n"
"\t\tfloat h = smoothstep(55.0,80.0,pos.y + 25.0*fbm(0.01*pos.xz) );\r\n"
"        float e = smoothstep(1.0-0.5*h,1.0-0.1*h,nor.y);\r\n"
"        float o = 0.3 + 0.7*smoothstep(0.0,0.1,nor.x+h*h);\r\n"
"        float s = h*e*o;\r\n"
"        col = mix( col, 0.35*vec3(0.62,0.65,0.7), smoothstep( 0.1, 0.9, s ) );\r\n"
"\r\n"
"         // lighting\t\t\r\n"
"        float amb = clamp(0.5+0.5*nor.y,0.0,1.0);\r\n"
"\t\tfloat dif = clamp( dot( light1, nor ), 0.0, 1.0 );\r\n"
"\t\tfloat bac = clamp( 0.2 + 0.8*dot( normalize( vec3(-light1.x, 0.0, light1.z ) ), nor ), 0.0, 1.0 );\r\n"
"\t\tfloat sh = 1.0; if( dif>=0.0001 ) sh = sinteresct(pos+light1*20.0,light1);\r\n"
"\t\t\r\n"
"\t\tvec3 lin  = vec3(0.0);\r\n"
"        lin += dif*vec3(8.00,5.50,3.00)*vec3( sh, sh*sh*0.5+0.5*sh, sh*sh*0.8+0.2*sh );\r\n"
"\t\tlin += amb*vec3(0.30,0.50,0.60);\r\n"
"        lin += bac*vec3(0.60,0.60,0.60);\r\n"
"\r\n"
"\t\tcol *= lin;\r\n"
"\t\t\r\n"
"\t\tfloat fo = 1.0-exp(-0.0007*t);\r\n"
"\t\tvec3 fco = vec3(0.55,0.65,0.75) + 0.6*vec3(1.0,0.8,0.5)*pow( sundot, 4.0 );\r\n"
"\t\tcol = mix( col, fco, fo );\r\n"
"\r\n"
"\t\tcol += 0.4*vec3(1.0,0.8,0.4)*pow( sundot, 8.0 )*(1.0-exp(-0.005*t));\r\n"
"\t}\r\n"
"\r\n"
"\t\r\n"
"\tcol = pow(col,vec3(0.45));\r\n"
"\r\n"
"\tcol = col*0.6 + 0.4*col*col*(3.0-2.0*col);\r\n"
"\t\r\n"
"\tvec2 uv = xy*0.5+0.5;\r\n"
"\tcol *= 0.7 + 0.3*pow(16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y),0.1);\r\n"
"\t\r\n"
"    #ifdef STEREO\t\r\n"
"    col *= vec3( isCyan, 1.0-isCyan, 1.0-isCyan );\t\r\n"
"\t#endif\r\n"
"\t\r\n"
"\tgl_FragColor=vec4(col,1.0);\r\n"
"}\r\n";

const char *sample2=
"float noise(vec3 p) //Thx to Las^Mercury\r\n"
"{\r\n"
"\tvec3 i = floor(p);\r\n"
"\tvec4 a = dot(i, vec3(1., 57., 21.)) + vec4(0., 57., 21., 78.);\r\n"
"\tvec3 f = cos((p-i)*acos(-1.))*(-.5)+.5;\r\n"
"\ta = mix(sin(cos(a)*a),sin(cos(1.+a)*(1.+a)), f.x);\r\n"
"\ta.xy = mix(a.xz, a.yw, f.y);\r\n"
"\treturn mix(a.x, a.y, f.z);\r\n"
"}\r\n"
"\r\n"
"float sphere(vec3 p, vec4 spr)\r\n"
"{\r\n"
"\treturn length(spr.xyz-p) - spr.w;\r\n"
"}\r\n"
"\r\n"
"float flame(vec3 p)\r\n"
"{\r\n"
"\tfloat d = sphere(p*vec3(1.,.5,1.), vec4(.0,-1.,.0,1.));\r\n"
"\treturn d + (noise(p+vec3(.0,iGlobalTime*2.,.0)) + noise(p*3.)*.5)*.25*(p.y) ;\r\n"
"}\r\n"
"\r\n"
"float scene(vec3 p)\r\n"
"{\r\n"
"\treturn min(100.-length(p) , abs(flame(p)) );\r\n"
"}\r\n"
"\r\n"
"vec4 raymarch(vec3 org, vec3 dir)\r\n"
"{\r\n"
"\tfloat d = 0.0, glow = 0.0, eps = 0.02;\r\n"
"\tvec3  p = org;\r\n"
"\tbool glowed = false;\r\n"
"\t\r\n"
"\tfor(int i=0; i<64; i++)\r\n"
"\t{\r\n"
"\t\td = scene(p) + eps;\r\n"
"\t\tp += d * dir;\r\n"
"\t\tif( d>eps )\r\n"
"\t\t{\r\n"
"\t\t\tif(flame(p) < .0)\r\n"
"\t\t\t\tglowed=true;\r\n"
"\t\t\tif(glowed)\r\n"
"       \t\t\tglow = float(i)/64.;\r\n"
"\t\t}\r\n"
"\t}\r\n"
"\treturn vec4(p,glow);\r\n"
"}\r\n"
"\r\n"
"void main()\r\n"
"{\r\n"
"\tvec2 v = -1.0 + 2.0 * gl_FragCoord.xy / iResolution.xy;\r\n"
"\tv.x *= iResolution.x/iResolution.y;\r\n"
"\t\r\n"
"\tvec3 org = vec3(0., -2., 4.);\r\n"
"\tvec3 dir = normalize(vec3(v.x*1.6, -v.y, -1.5));\r\n"
"\t\r\n"
"\tvec4 p = raymarch(org, dir);\r\n"
"\tfloat glow = p.w;\r\n"
"\t\r\n"
"\tvec4 col = mix(vec4(1.,.5,.1,1.), vec4(0.1,.5,1.,1.), p.y*.02+.4);\r\n"
"\t\r\n"
"\tgl_FragColor = mix(vec4(0.), col, pow(glow*2.,4.));\r\n"
"\t//gl_FragColor = mix(vec4(1.), mix(vec4(1.,.5,.1,1.),vec4(0.1,.5,1.,1.),p.y*.02+.4), pow(glow*2.,4.));\r\n"
"\r\n"
"}\r\n";

const char *sample3=
"// Number Printing - @P_Malin\r\n"
"// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n"
"\r\n"
"//#define BITMAP_VERSION\r\n"
"\r\n"
"const float kCharBlank = 12.0;\r\n"
"const float kCharMinus = 11.0;\r\n"
"const float kCharDecimalPoint = 10.0;\r\n"
"\r\n"
"#ifndef BITMAP_VERSION\r\n"
"\r\n"
"float InRect(const in vec2 vUV, const in vec4 vRect)\r\n"
"{\r\n"
"\tvec2 vTestMin = step(vRect.xy, vUV.xy);\r\n"
"\tvec2 vTestMax = step(vUV.xy, vRect.zw);\t\r\n"
"\tvec2 vTest = vTestMin * vTestMax;\r\n"
"\treturn vTest.x * vTest.y;\r\n"
"}\r\n"
"\r\n"
"float SampleDigit(const in float fDigit, const in vec2 vUV)\r\n"
"{\r\n"
"\tconst float x0 = 0.0 / 4.0;\r\n"
"\tconst float x1 = 1.0 / 4.0;\r\n"
"\tconst float x2 = 2.0 / 4.0;\r\n"
"\tconst float x3 = 3.0 / 4.0;\r\n"
"\tconst float x4 = 4.0 / 4.0;\r\n"
"\t\r\n"
"\tconst float y0 = 0.0 / 5.0;\r\n"
"\tconst float y1 = 1.0 / 5.0;\r\n"
"\tconst float y2 = 2.0 / 5.0;\r\n"
"\tconst float y3 = 3.0 / 5.0;\r\n"
"\tconst float y4 = 4.0 / 5.0;\r\n"
"\tconst float y5 = 5.0 / 5.0;\r\n"
"\r\n"
"\t// In this version each digit is made of up to 3 rectangles which we XOR together to get the result\r\n"
"\t\r\n"
"\tvec4 vRect0 = vec4(0.0);\r\n"
"\tvec4 vRect1 = vec4(0.0);\r\n"
"\tvec4 vRect2 = vec4(0.0);\r\n"
"\t\t\r\n"
"\tif(fDigit < 0.5) // 0\r\n"
"\t{\r\n"
"\t\tvRect0 = vec4(x0, y0, x3, y5); vRect1 = vec4(x1, y1, x2, y4);\r\n"
"\t}\r\n"
"\telse if(fDigit < 1.5) // 1\r\n"
"\t{\r\n"
"\t\tvRect0 = vec4(x1, y0, x2, y5); vRect1 = vec4(x0, y0, x0, y0);\r\n"
"\t}\r\n"
"\telse if(fDigit < 2.5) // 2\r\n"
"\t{\r\n"
"\t\tvRect0 = vec4(x0, y0, x3, y5); vRect1 = vec4(x0, y3, x2, y4); vRect2 = vec4(x1, y1, x3, y2);\r\n"
"\t}\r\n"
"\telse if(fDigit < 3.5) // 3\r\n"
"\t{\r\n"
"\t\tvRect0 = vec4(x0, y0, x3, y5); vRect1 = vec4(x0, y3, x2, y4); vRect2 = vec4(x0, y1, x2, y2);\r\n"
"\t}\r\n"
"\telse if(fDigit < 4.5) // 4\r\n"
"\t{\r\n"
"\t\tvRect0 = vec4(x0, y1, x2, y5); vRect1 = vec4(x1, y2, x2, y5); vRect2 = vec4(x2, y0, x3, y3);\r\n"
"\t}\r\n"
"\telse if(fDigit < 5.5) // 5\r\n"
"\t{\r\n"
"\t\tvRect0 = vec4(x0, y0, x3, y5); vRect1 = vec4(x1, y3, x3, y4); vRect2 = vec4(x0, y1, x2, y2);\r\n"
"\t}\r\n"
"\telse if(fDigit < 6.5) // 6\r\n"
"\t{\r\n"
"\t\tvRect0 = vec4(x0, y0, x3, y5); vRect1 = vec4(x1, y3, x3, y4); vRect2 = vec4(x1, y1, x2, y2);\r\n"
"\t}\r\n"
"\telse if(fDigit < 7.5) // 7\r\n"
"\t{\r\n"
"\t\tvRect0 = vec4(x0, y0, x3, y5); vRect1 = vec4(x0, y0, x2, y4);\r\n"
"\t}\r\n"
"\telse if(fDigit < 8.5) // 8\r\n"
"\t{\r\n"
"\t\tvRect0 = vec4(x0, y0, x3, y5); vRect1 = vec4(x1, y1, x2, y2); vRect2 = vec4(x1, y3, x2, y4);\r\n"
"\t}\r\n"
"\telse if(fDigit < 9.5) // 9\r\n"
"\t{\r\n"
"\t\tvRect0 = vec4(x0, y0, x3, y5); vRect1 = vec4(x1, y3, x2, y4); vRect2 = vec4(x0, y1, x2, y2);\r\n"
"\t}\r\n"
"\telse if(fDigit < 10.5) // '.'\r\n"
"\t{\r\n"
"\t\tvRect0 = vec4(x1, y0, x2, y1);\r\n"
"\t}\r\n"
"\telse if(fDigit < 11.5) // '-'\r\n"
"\t{\r\n"
"\t\tvRect0 = vec4(x0, y2, x3, y3);\r\n"
"\t}\t\r\n"
"\t\r\n"
"\tfloat fResult = InRect(vUV, vRect0) + InRect(vUV, vRect1) + InRect(vUV, vRect2);\r\n"
"\t\r\n"
"\treturn mod(fResult, 2.0);\r\n"
"}\r\n"
"\r\n"
"#else\r\n"
"\r\n"
"float SampleDigit(const in float fDigit, const in vec2 vUV)\r\n"
"{\t\t\r\n"
"\tif(vUV.x < 0.0) return 0.0;\r\n"
"\tif(vUV.y < 0.0) return 0.0;\r\n"
"\tif(vUV.x >= 1.0) return 0.0;\r\n"
"\tif(vUV.y >= 1.0) return 0.0;\r\n"
"\t\r\n"
"\t// In this version, each digit is made up of a 4x5 array of bits\r\n"
"\t\r\n"
"\tfloat fDigitBinary = 0.0;\r\n"
"\t\r\n"
"\tif(fDigit < 0.5) // 0\r\n"
"\t{\r\n"
"\t\tfDigitBinary = 7.0 + 5.0 * 16.0 + 5.0 * 256.0 + 5.0 * 4096.0 + 7.0 * 65536.0;\r\n"
"\t}\r\n"
"\telse if(fDigit < 1.5) // 1\r\n"
"\t{\r\n"
"\t\tfDigitBinary = 2.0 + 2.0 * 16.0 + 2.0 * 256.0 + 2.0 * 4096.0 + 2.0 * 65536.0;\r\n"
"\t}\r\n"
"\telse if(fDigit < 2.5) // 2\r\n"
"\t{\r\n"
"\t\tfDigitBinary = 7.0 + 1.0 * 16.0 + 7.0 * 256.0 + 4.0 * 4096.0 + 7.0 * 65536.0;\r\n"
"\t}\r\n"
"\telse if(fDigit < 3.5) // 3\r\n"
"\t{\r\n"
"\t\tfDigitBinary = 7.0 + 4.0 * 16.0 + 7.0 * 256.0 + 4.0 * 4096.0 + 7.0 * 65536.0;\r\n"
"\t}\r\n"
"\telse if(fDigit < 4.5) // 4\r\n"
"\t{\r\n"
"\t\tfDigitBinary = 4.0 + 7.0 * 16.0 + 5.0 * 256.0 + 1.0 * 4096.0 + 1.0 * 65536.0;\r\n"
"\t}\r\n"
"\telse if(fDigit < 5.5) // 5\r\n"
"\t{\r\n"
"\t\tfDigitBinary = 7.0 + 4.0 * 16.0 + 7.0 * 256.0 + 1.0 * 4096.0 + 7.0 * 65536.0;\r\n"
"\t}\r\n"
"\telse if(fDigit < 6.5) // 6\r\n"
"\t{\r\n"
"\t\tfDigitBinary = 7.0 + 5.0 * 16.0 + 7.0 * 256.0 + 1.0 * 4096.0 + 7.0 * 65536.0;\r\n"
"\t}\r\n"
"\telse if(fDigit < 7.5) // 7\r\n"
"\t{\r\n"
"\t\tfDigitBinary = 4.0 + 4.0 * 16.0 + 4.0 * 256.0 + 4.0 * 4096.0 + 7.0 * 65536.0;\r\n"
"\t}\r\n"
"\telse if(fDigit < 8.5) // 8\r\n"
"\t{\r\n"
"\t\tfDigitBinary = 7.0 + 5.0 * 16.0 + 7.0 * 256.0 + 5.0 * 4096.0 + 7.0 * 65536.0;\r\n"
"\t}\r\n"
"\telse if(fDigit < 9.5) // 9\r\n"
"\t{\r\n"
"\t\tfDigitBinary = 7.0 + 4.0 * 16.0 + 7.0 * 256.0 + 5.0 * 4096.0 + 7.0 * 65536.0;\r\n"
"\t}\r\n"
"\telse if(fDigit < 10.5) // '.'\r\n"
"\t{\r\n"
"\t\tfDigitBinary = 2.0 + 0.0 * 16.0 + 0.0 * 256.0 + 0.0 * 4096.0 + 0.0 * 65536.0;\r\n"
"\t}\r\n"
"\telse if(fDigit < 11.5) // '-'\r\n"
"\t{\r\n"
"\t\tfDigitBinary = 0.0 + 0.0 * 16.0 + 7.0 * 256.0 + 0.0 * 4096.0 + 0.0 * 65536.0;\r\n"
"\t}\r\n"
"\t\r\n"
"\tvec2 vPixel = floor(vUV * vec2(4.0, 5.0));\r\n"
"\tfloat fIndex = vPixel.x + (vPixel.y * 4.0);\r\n"
"\t\r\n"
"\treturn mod(floor(fDigitBinary / pow(2.0, fIndex)), 2.0);\r\n"
"}\r\n"
"\r\n"
"#endif\r\n"
"\r\n"
"float PrintValue(const in vec2 vStringCharCoords, const in float fValue, const in float fMaxDigits, const in float fDecimalPlaces)\r\n"
"{\r\n"
"\tfloat fAbsValue = abs(fValue);\r\n"
"\t\r\n"
"\tfloat fStringCharIndex = floor(vStringCharCoords.x);\r\n"
"\t\r\n"
"\tfloat fLog10Value = log2(fAbsValue) / log2(10.0);\r\n"
"\tfloat fBiggestDigitIndex = max(floor(fLog10Value), 0.0);\r\n"
"\t\r\n"
"\t// This is the character we are going to display for this pixel\r\n"
"\tfloat fDigitCharacter = kCharBlank;\r\n"
"\t\r\n"
"\tfloat fDigitIndex = fMaxDigits - fStringCharIndex;\r\n"
"\tif(fDigitIndex > (-fDecimalPlaces - 1.5))\r\n"
"\t{\r\n"
"\t\tif(fDigitIndex > fBiggestDigitIndex)\r\n"
"\t\t{\r\n"
"\t\t\tif(fValue < 0.0)\r\n"
"\t\t\t{\r\n"
"\t\t\t\tif(fDigitIndex < (fBiggestDigitIndex+1.5))\r\n"
"\t\t\t\t{\r\n"
"\t\t\t\t\tfDigitCharacter = kCharMinus;\r\n"
"\t\t\t\t}\r\n"
"\t\t\t}\r\n"
"\t\t}\r\n"
"\t\telse\r\n"
"\t\t{\t\t\r\n"
"\t\t\tif(fDigitIndex == -1.0)\r\n"
"\t\t\t{\r\n"
"\t\t\t\tif(fDecimalPlaces > 0.0)\r\n"
"\t\t\t\t{\r\n"
"\t\t\t\t\tfDigitCharacter = kCharDecimalPoint;\r\n"
"\t\t\t\t}\r\n"
"\t\t\t}\r\n"
"\t\t\telse\r\n"
"\t\t\t{\r\n"
"\t\t\t\tif(fDigitIndex < 0.0)\r\n"
"\t\t\t\t{\r\n"
"\t\t\t\t\t// move along one to account for .\r\n"
"\t\t\t\t\tfDigitIndex += 1.0;\r\n"
"\t\t\t\t}\r\n"
"\r\n"
"\t\t\t\tfloat fDigitValue = (fAbsValue / (pow(10.0, fDigitIndex)));\r\n"
"\r\n"
"\t\t\t\t// This is inaccurate - I think because I treat each digit independently\r\n"
"\t\t\t\t// The value 2.0 gets printed as 2.09 :/\r\n"
"\t\t\t\t//fDigitCharacter = mod(floor(fDigitValue), 10.0);\r\n"
"\t\t\t\tfDigitCharacter = mod(floor(0.0001+fDigitValue), 10.0); // fix from iq\r\n"
"\t\t\t}\t\t\r\n"
"\t\t}\r\n"
"\t}\r\n"
"\r\n"
"\tvec2 vCharPos = vec2(fract(vStringCharCoords.x), vStringCharCoords.y);\r\n"
"\r\n"
"\treturn SampleDigit(fDigitCharacter, vCharPos);\t\r\n"
"}\r\n"
"\r\n"
"float PrintValue(const in vec2 vPixelCoords, const in vec2 vFontSize, const in float fValue, const in float fMaxDigits, const in float fDecimalPlaces)\r\n"
"{\r\n"
"\treturn PrintValue((gl_FragCoord.xy - vPixelCoords) / vFontSize, fValue, fMaxDigits, fDecimalPlaces);\r\n"
"}\r\n"
"\r\n"
"float GetCurve(float x)\r\n"
"{\r\n"
"\treturn sin( x * 3.14159 * 4.0 );\r\n"
"}\r\n"
"\r\n"
"float GetCurveDeriv(float x) \r\n"
"{ \r\n"
"\treturn 3.14159 * 4.0 * cos( x * 3.14159 * 4.0 ); \r\n"
"}\r\n"
"\r\n"
"void main(void)\r\n"
"{\r\n"
"\tvec3 vColour = vec3(0.0);\r\n"
"\r\n"
"\t// Multiples of 4x5 work best\r\n"
"\tvec2 vFontSize = vec2(8.0, 15.0);\r\n"
"\r\n"
"\t// Draw Horizontal Line\r\n"
"\tif(abs(gl_FragCoord.y - iResolution.y * 0.5) < 1.0)\r\n"
"\t{\r\n"
"\t\tvColour = vec3(0.25);\r\n"
"\t}\r\n"
"\t\r\n"
"\t// Draw Sin Wave\r\n"
"\t// See the comment from iq or this page\r\n"
"\t// http://www.iquilezles.org/www/articles/distance/distance.htm\r\n"
"\tfloat fCurveX = gl_FragCoord.x / iResolution.x;\r\n"
"\tfloat fSinY = (GetCurve(fCurveX) * 0.25 + 0.5) * iResolution.y;\r\n"
"\tfloat fSinYdX = (GetCurveDeriv(fCurveX) * 0.25) * iResolution.y / iResolution.x;\r\n"
"\tfloat fDistanceToCurve = abs(fSinY - gl_FragCoord.y) / sqrt(1.0+fSinYdX*fSinYdX);\r\n"
"\tfloat fSetPixel = fDistanceToCurve - 1.0; // Add more thickness\r\n"
"\tvColour = mix(vec3(1.0, 0.0, 0.0), vColour, clamp(fSetPixel, 0.0, 1.0));\t\r\n"
"\r\n"
"\t// Draw Sin Value\t\r\n"
"\tfloat fValue4 = GetCurve(iMouse.x / iResolution.x);\r\n"
"\tfloat fPixelYCoord = (fValue4 * 0.25 + 0.5) * iResolution.y;\r\n"
"\t\r\n"
"\t// Plot Point on Sin Wave\r\n"
"\tfloat fDistToPointA = length( vec2(iMouse.x, fPixelYCoord) - gl_FragCoord.xy) - 4.0;\r\n"
"\tvColour = mix(vColour, vec3(0.0, 0.0, 1.0), (1.0 - clamp(fDistToPointA, 0.0, 1.0)));\r\n"
"\t\r\n"
"\t// Plot Mouse Pos\r\n"
"\tfloat fDistToPointB = length( vec2(iMouse.x, iMouse.y) - gl_FragCoord.xy) - 4.0;\r\n"
"\tvColour = mix(vColour, vec3(0.0, 1.0, 0.0), (1.0 - clamp(fDistToPointB, 0.0, 1.0)));\r\n"
"\t\r\n"
"\t// Print Sin Value\r\n"
"\tvec2 vPixelCoord4 = vec2(iMouse.x, fPixelYCoord) + vec2(4.0, 4.0);\r\n"
"\tfloat fDigits = 1.0;\r\n"
"\tfloat fDecimalPlaces = 2.0;\r\n"
"\tfloat fIsDigit4 = PrintValue(vPixelCoord4, vFontSize, fValue4, fDigits, fDecimalPlaces);\r\n"
"\tvColour = mix( vColour, vec3(0.0, 0.0, 1.0), fIsDigit4);\r\n"
"\t\r\n"
"\t// Print Shader Time\r\n"
"\tvec2 vPixelCoord1 = vec2(96.0, 5.0);\r\n"
"\tfloat fValue1 = iGlobalTime;\r\n"
"\tfDigits = 6.0;\r\n"
"\tfloat fIsDigit1 = PrintValue(vPixelCoord1, vFontSize, fValue1, fDigits, fDecimalPlaces);\r\n"
"\tvColour = mix( vColour, vec3(0.0, 1.0, 1.0), fIsDigit1);\r\n"
"\r\n"
"\t// Print Date\r\n"
"\tvColour = mix( vColour, vec3(1.0, 1.0, 0.0), PrintValue(vec2(0.0, 5.0), vFontSize, iDate.x, 4.0, 0.0));\r\n"
"\tvColour = mix( vColour, vec3(1.0, 1.0, 0.0), PrintValue(vec2(0.0 + 48.0, 5.0), vFontSize, iDate.y + 1.0, 2.0, 0.0));\r\n"
"\tvColour = mix( vColour, vec3(1.0, 1.0, 0.0), PrintValue(vec2(0.0 + 72.0, 5.0), vFontSize, iDate.z, 2.0, 0.0));\r\n"
"\r\n"
"\t// Draw Time\r\n"
"\tvColour = mix( vColour, vec3(1.0, 0.0, 1.0), PrintValue(vec2(184.0, 5.0), vFontSize, mod(iDate.w / (60.0 * 60.0), 12.0), 2.0, 0.0));\r\n"
"\tvColour = mix( vColour, vec3(1.0, 0.0, 1.0), PrintValue(vec2(184.0 + 24.0, 5.0), vFontSize, mod(iDate.w / 60.0, 60.0), 2.0, 0.0));\r\n"
"\tvColour = mix( vColour, vec3(1.0, 0.0, 1.0), PrintValue(vec2(184.0 + 48.0, 5.0), vFontSize, mod(iDate.w, 60.0), 2.0, 0.0));\r\n"
"\t\r\n"
"\tif(iMouse.x > 0.0)\r\n"
"\t{\r\n"
"\t\t// Print Mouse X\r\n"
"\t\tvec2 vPixelCoord2 = iMouse.xy + vec2(-52.0, 6.0);\r\n"
"\t\tfloat fValue2 = iMouse.x / iResolution.x;\r\n"
"\t\tfDigits = 1.0;\r\n"
"\t\tfDecimalPlaces = 3.0;\r\n"
"\t\tfloat fIsDigit2 = PrintValue(vPixelCoord2, vFontSize, fValue2, fDigits, fDecimalPlaces);\r\n"
"\t\tvColour = mix( vColour, vec3(0.0, 1.0, 0.0), fIsDigit2);\r\n"
"\t\t\r\n"
"\t\t// Print Mouse Y\r\n"
"\t\tvec2 vPixelCoord3 = iMouse.xy + vec2(0.0, 6.0);\r\n"
"\t\tfloat fValue3 = iMouse.y / iResolution.y;\r\n"
"\t\tfDigits = 1.0;\r\n"
"\t\tfloat fIsDigit3 = PrintValue(vPixelCoord3, vFontSize, fValue3, fDigits, fDecimalPlaces);\r\n"
"\t\tvColour = mix( vColour, vec3(0.0, 1.0, 0.0), fIsDigit3);\r\n"
"\t}\r\n"
"\t\r\n"
"\tgl_FragColor = vec4(vColour,1.0);\r\n"
"}"
;

const char *sample4={
"/*by musk License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n"
"\r\n"
"\tI've been planning to do something like this for years,\r\n"
"\tbut I never had the knowledge or time. Today I have both! Oh yeah!\r\n"
"\r\n"
"\tInspired by the floating mountains of avatar. \r\n"
"\tGoing for a more exotic tropical look.\r\n"
"\r\n"
"\tInstructions:\r\n"
"\r\n"
"\t\t- if you wait you get different ladscapes\r\n"
"\t\t- click and drag slowly to look around with mouse\r\n"
"\t\t- wait until water rises and lowers, \r\n"
"\t\t- if bored with landscape change time_offset parameter\r\n"
"\t\t- you can pause and look around with mouse\r\n"
"\t\t- to increase performance reduce iteration count\r\n"
"\t\t- you can increase precision with high_precision_trace switch\r\n"
"\r\n"
"\tScreenshot: http://i.snag.gy/ckSmg.jpg\r\n"
"\tSoundtrack: http://www.youtube.com/watch?v=aHMmoSX3hhM\r\n"
"\r\n"
"\tFeatures:\r\n"
"\t\r\n"
"\t\t- mouselook\r\n"
"\t\t- soft shadows shadows\r\n"
"\t\t- ambient occlusion\r\n"
"\t\t- 2 distance fields & 2 materials\r\n"
"\t\t- lens flare with occlusion\r\n"
"\t\t- moving clouds & moving lightsource\r\n"
"\t\t- 3d noise based terrain\r\n"
"\t\t- 2d texture based mipmapped noise functions\r\n"
"\t\t- reflection with occlusion\r\n"
"\t\t- depth of field (nearby objects)\r\n"
"\t\t- motion blur\r\n"
"\t\t- post processing\r\n"
"\t\t- changing water level\r\n"
"\r\n"
"\tI'm getting 20-30 fps on nvidia 9800. (not fullscreen)\r\n"
"\r\n"
"\tPlease post bugs in comment section!!! \r\n"
"\tYou can compare the render with my screenshot.\r\n"
"\tScreenshot again: http://i.snag.gy/ckSmg.jpg\r\n"
"\r\n"
"\tHistory:\r\n"
"\r\n"
"\t\t- 19/02/2014 published\r\n"
"\r\n"
"*/\r\n"
"\r\n"
"//parameters\r\n"
"#define time_offset 0\r\n"
"#define general_speed 1.0\r\n"
"#define camera_speed 2.0\r\n"
"#define trace_iterations 100\r\n"
"#define light_occlusion_iterations 10\r\n"
"#define relection_occlusion_iterations 10\r\n"
"#define flare_occlusion_iterations 20\r\n"
"\r\n"
"//switches\r\n"
"//#define high_precision_trace\r\n"
"#define motion_blur\r\n"
"#define render_water\r\n"
"#define render_terrain\r\n"
"\r\n"
"//the following switches exclude each other\r\n"
"//#define shading_normal_only\r\n"
"//#define shading_light_occlusion_only\r\n"
"//#define shading_ambient_occlusion_only\r\n"
"\r\n"
"//functions that build rotation matrixes\r\n"
"mat2 rotate_2D(float a){float sa = sin(a); float ca = cos(a); return mat2(ca,sa,-sa,ca);}\r\n"
"mat3 rotate_x(float a){float sa = sin(a); float ca = cos(a); return mat3(1.,.0,.0,    .0,ca,sa,   .0,-sa,ca);}\r\n"
"mat3 rotate_y(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,.0,sa,    .0,1.,.0,   -sa,.0,ca);}\r\n"
"mat3 rotate_z(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,sa,.0,    -sa,ca,.0,  .0,.0,1.);}\r\n"
"\r\n"
"//2D texture based 3 component 1D, 2D, 3D noise\r\n"
"vec3 noise(float p){return texture2D(iChannel0,vec2(p/iChannelResolution[0].x,.0)).xyz;}\r\n"
"vec3 noise(vec2 p){return texture2D(iChannel0,p/iChannelResolution[0].xy).xyz;}\r\n"
"vec3 noise(vec3 p){float m = mod(p.z,1.0);float s = p.z-m; float sprev = s-1.0;if (mod(s,2.0)==1.0) { s--; sprev++; m = 1.0-m; };return mix(texture2D(iChannel0,p.xy/iChannelResolution[0].xy+noise(sprev).yz).xyz,texture2D(iChannel0,p.xy/iChannelResolution[0].xy+noise(s).yz).xyz,m);}\r\n"
"\r\n"
"vec3 noise(float p, float lod){return texture2D(iChannel0,vec2(p/iChannelResolution[0].x,.0),lod).xyz;}\r\n"
"vec3 noise(vec2 p, float lod){return texture2D(iChannel0,p/iChannelResolution[0].xy,lod).xyz;}\r\n"
"vec3 noise(vec3 p, float lod){float m = mod(p.z,1.0);float s = p.z-m; float sprev = s-1.0;if (mod(s,2.0)==1.0) { s--; sprev++; m = 1.0-m; };return mix(texture2D(iChannel0,p.xy/iChannelResolution[0].xy+noise(sprev,lod).yz,lod).xyz,texture2D(iChannel0,p.xy/iChannelResolution[0].xy+noise(s,lod).yz,lod).xyz,m);}\r\n"
"\r\n"
"\r\n"
"vec3 air_color = vec3(.3,.45,.6);\r\n"
"#ifdef motion_blur\r\n"
"float t = (iGlobalTime + noise(gl_FragCoord.xy).y/24.0 + float(time_offset))*general_speed;\r\n"
"#else\r\n"
"float t = (iGlobalTime + float(time_offset))*general_speed;\r\n"
"#endif\r\n"
"//dinst2 function computes distance and fog density ;)\r\n"
"#ifdef render_terrain\r\n"
"vec2 terra(vec3 p)\r\n"
"{\r\n"
"\tfloat q = length(p.xz)*.125;\r\n"
"\tfloat lod = -16.0;\r\n"
"\tvec3 nnn = noise(p*.125,lod);\r\n"
"\tvec3 n1 =  p.y*.0125+nnn*8.0;\r\n"
"\tvec3 n2 = p.y*.15+noise(p*.25+nnn.y,lod)*4.0;\r\n"
"\tvec3 n3 = noise(p*vec3(1.0,0.5,1.0)+nnn.z,lod);\r\n"
"\tfloat d = n1.x+n2.x+n3.x + noise(p.xz*4.10).x*.44*nnn.z;\r\n"
"\tfloat density  = max(.0,pow(-p.y*.5,2.5)*.2)*(max(.0,pow(n1.y+nnn.z*.5+n2.y*.1,3.0)*.0000016)+.000025);\r\n"
"\treturn vec2(d,density*.3);\r\n"
"}\r\n"
"#else\r\n"
"vec2 terra(vec3 p)\r\n"
"{\r\n"
"\treturn vec2(1024.0*1024.0,.0);\r\n"
"}\r\n"
"#endif\r\n"
"\r\n"
"#ifdef render_water\r\n"
"vec2 water(vec3 p)\r\n"
"{\r\n"
"\treturn vec2(p.y+38.0-sin(t*.04)*12.0,.0);\r\n"
"}\r\n"
"#else\r\n"
"vec2 water(vec3 p)\r\n"
"{\r\n"
"\treturn vec2(1024.0*1024.0,.0);\r\n"
"}\r\n"
"#endif\r\n"
"\r\n"
"vec2 dist2(vec3 p)\r\n"
"{\r\n"
"\tvec2 f1 = terra(p);\r\n"
"\tvec2 f2 = water(p);\r\n"
"\treturn vec2(min(f1.x,f2.x),f1.y+f2.y);\r\n"
"}\r\n"
"\r\n"
"float dist(vec3 p)\r\n"
"{\r\n"
"\treturn dist2(p).x;\r\n"
"}\r\n"
"\r\n"
"float amb_occ(vec3 p)\r\n"
"{\r\n"
"\tfloat acc=0.0;\r\n"
"\t#define ambocce 1.9\r\n"
"\r\n"
"\tacc+=dist(p+vec3(-ambocce,-ambocce,-ambocce));\r\n"
"\tacc+=dist(p+vec3(-ambocce,-ambocce,+ambocce));\r\n"
"\tacc+=dist(p+vec3(-ambocce,+ambocce,-ambocce));\r\n"
"\tacc+=dist(p+vec3(-ambocce,+ambocce,+ambocce));\r\n"
"\tacc+=dist(p+vec3(+ambocce,-ambocce,-ambocce));\r\n"
"\tacc+=dist(p+vec3(+ambocce,-ambocce,+ambocce));\r\n"
"\tacc+=dist(p+vec3(+ambocce,+ambocce,-ambocce));\r\n"
"\tacc+=dist(p+vec3(+ambocce,+ambocce,+ambocce));\r\n"
"\treturn 0.5+acc /(16.0*ambocce);\r\n"
"}\r\n"
"\r\n"
"vec3 lensflare(vec2 uv,vec2 pos)\r\n"
"{\r\n"
"\tvec2 main = uv-pos;\r\n"
"\tvec2 uvd = uv*(length(uv));\r\n"
"\t\r\n"
"\tfloat ang = atan(-main.x,-main.y);\r\n"
"\tfloat dist=length(main); dist = pow(dist,.1);\r\n"
"\t\r\n"
"\tfloat f0 = 1.0/(length(uv-pos)*32.0+1.0);\r\n"
"\t\r\n"
"\tf0 = f0+f0*(sin(noise((pos.x+pos.y)*2.2+ang*4.0+5.954)*16.0)*.1+dist*.1+.8).x;\r\n"
"\t\r\n"
"\tfloat f1 = max(0.01-pow(length(uv+1.2*pos),1.9),.0)*7.0;\r\n"
"\r\n"
"\tfloat f2 = max(1.0/(1.0+32.0*pow(length(uvd+0.8*pos),2.0)),.0)*00.25;\r\n"
"\tfloat f22 = max(1.0/(1.0+32.0*pow(length(uvd+0.85*pos),2.0)),.0)*00.23;\r\n"
"\tfloat f23 = max(1.0/(1.0+32.0*pow(length(uvd+0.9*pos),2.0)),.0)*00.21;\r\n"
"\t\r\n"
"\tvec2 uvx = mix(uv,uvd,-0.5);\r\n"
"\t\r\n"
"\tfloat f4 = max(0.01-pow(length(uvx+0.4*pos),2.4),.0)*6.0;\r\n"
"\tfloat f42 = max(0.01-pow(length(uvx+0.45*pos),2.4),.0)*5.0;\r\n"
"\tfloat f43 = max(0.01-pow(length(uvx+0.5*pos),2.4),.0)*3.0;\r\n"
"\t\r\n"
"\tuvx = mix(uv,uvd,-.4);\r\n"
"\t\r\n"
"\tfloat f5 = max(0.01-pow(length(uvx+0.2*pos),5.5),.0)*2.0;\r\n"
"\tfloat f52 = max(0.01-pow(length(uvx+0.4*pos),5.5),.0)*2.0;\r\n"
"\tfloat f53 = max(0.01-pow(length(uvx+0.6*pos),5.5),.0)*2.0;\r\n"
"\t\r\n"
"\tuvx = mix(uv,uvd,-0.5);\r\n"
"\t\r\n"
"\tfloat f6 = max(0.01-pow(length(uvx-0.3*pos),1.6),.0)*6.0;\r\n"
"\tfloat f62 = max(0.01-pow(length(uvx-0.325*pos),1.6),.0)*3.0;\r\n"
"\tfloat f63 = max(0.01-pow(length(uvx-0.35*pos),1.6),.0)*5.0;\r\n"
"\t\r\n"
"\tvec3 c = vec3(.0);\r\n"
"\t\r\n"
"\tc.r+=f2+f4+f5+f6; c.g+=f22+f42+f52+f62; c.b+=f23+f43+f53+f63;\r\n"
"\tc = c*1.3 - vec3(length(uvd)*.05);\r\n"
"\tc+=vec3(f0);\r\n"
"\t\r\n"
"\treturn c*=(noise(vec3(uv*.7,t*.03712))*.6+.7)*(noise(uv*8.0).y*.4+.9);;\r\n"
"}\r\n"
"\r\n"
"vec3 normal(vec3 p) //returns the normal, uses the distance function\r\n"
"{\r\n"
"\tfloat e = .1;\r\n"
"\tfloat d=dist(p);\r\n"
"\tvec3 n = normalize(vec3(dist(p+vec3(e,0,0))-d,dist(p+vec3(0,e,0))-d,dist(p+vec3(0,0,e))-d));\r\n"
"\tn = normalize(n*4.0+( noise(p*vec3(2.5,14.5,2.5))-vec3(.5) )*2.0+( noise(p*7.0)-vec3(.5)) );\r\n"
"\treturn n;\r\n"
"\t\r\n"
"}\r\n"
"\r\n"
"float cloud(vec3 d)\r\n"
"{\r\n"
"\tfloat a = .0;\r\n"
"\tvec2 geo = d.xz/(pow(d.y,.5))*.5;\r\n"
"\tgeo += + vec2(t*.005);\r\n"
"\tgeo += noise(geo).yz*.5;\r\n"
"\ta = (noise(geo*256.0).y)*.02+(noise(geo*08.0).y)*.30;\r\n"
"\tgeo += noise(geo*4.0).yz*.2;\r\n"
"\ta = a\r\n"
"\t\t+(noise(geo*32.0).y)*.07\r\n"
"\t\t+(noise(geo*16.0).y)*.15\r\n"
"\t\t+(noise(geo*128.0).y)*.03\r\n"
"\t\t+(noise(geo*04.0).y)*.60\r\n"
"\t\t;\r\n"
"\ta = min(max(.0,a),1.0);\r\n"
"\treturn a;\r\n"
"}\r\n"
"\r\n"
"vec3 backdrop(vec3 d)\r\n"
"{\r\n"
"\tfloat cl = cloud(d);\r\n"
"\tvec3 ac = air_color*(-d.y*.5+.7);\r\n"
"\treturn mix(mix(mix(ac,vec3(1.0),pow(cl,5.0)),vec3(.1)+ac*.5,pow(cl,4.0)*.5),ac,.7);;\r\n"
"}\r\n"
"\r\n"
"void main(void)\r\n"
"{\r\n"
"\tvec2 uv = gl_FragCoord.xy / iResolution.xy - 0.5;\r\n"
"\tuv.x *= iResolution.x/iResolution.y; //fix aspect ratio\r\n"
"\tvec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5,iMouse.z-.5);\r\n"
"\t\r\n"
"\tvec3 p = vec3(.0,.0,8.0);\r\n"
"\tvec3 d = normalize(vec3(uv,-0.5 ));\r\n"
"\t\r\n"
"\t\r\n"
"\t\r\n"
"\tmouse.xy+=vec2(.7422+sin(t*.16)*.01,.5+sin(t*.17)*.01);\r\n"
"\t\r\n"
"\tmouse*=16.0;\r\n"
"\t\r\n"
"\tmat3 rotation = rotate_x(mouse.y)*rotate_y(mouse.x);\r\n"
"\tmat3 inv_rotation = rotate_y(-mouse.x)*rotate_x(-mouse.y);\r\n"
"\tp*=rotation; d*=rotation;\r\n"
"\t\r\n"
"\tp.x+=t*camera_speed-1.0/(t*.3)-540.0+sin(t*.031)*40.0;\r\n"
"\tp.y-=24.0;\r\n"
"\tp.xz+=vec2(sin(t*.12),sin(t*.13))*4.0;\r\n"
"\t\r\n"
"\tvec3 start_pos = p;\r\n"
"\t\r\n"
"\td+=(noise(uv*iResolution.y)-vec3(.5))*.001;\r\n"
"\tp+=d*noise(uv*iResolution.y)*.05;\r\n"
"\t\r\n"
"\tvec3 c = backdrop(d);\r\n"
"\t\r\n"
"\tfloat acc = .0;\r\n"
"\tfloat ds;\r\n"
"\tfor (int i=0; i<trace_iterations; i++)\r\n"
"\t{\r\n"
"\t\tvec2 distres = dist2(p);\r\n"
"\t\t#ifdef high_precision_trace\r\n"
"\t\tfloat ds = distres.x*.5;\r\n"
"\t\t#else\r\n"
"\t\tfloat ds = distres.x;\r\n"
"\t\t#endif\r\n"
"\t\tfloat de = distres.y;\r\n"
"\t\tp+=ds*d;\r\n"
"\t\tacc+=de*ds;\r\n"
"\t\t//if (ds<.01) break;\r\n"
"\t\tif (acc>1.0 || ds<.01|| p.y>8.0) \r\n"
"\t\t{\r\n"
"\t\t\tbreak;\r\n"
"\t\t}\r\n"
"\t}\r\n"
"\t\r\n"
"\tacc = min(acc,1.0);\r\n"
"\t\r\n"
"\tvec3 light = normalize(vec3(sin(t*0.047),1.0-cos(t*.0471)*cos(t*.0271)*.8,cos(t*.0317)));\r\n"
"\t\r\n"
"\tfloat flare = dot(d,light)*.5+.5;\r\n"
"\tc+=pow(flare,800.0)*1.5;\r\n"
"\t\r\n"
"\tif (acc<1.0&&dist(p)<2.1)\r\n"
"\t{\r\n"
"\t\tfloat od = 1.0;\r\n"
"\t\tvec3 odir = light;\r\n"
"\t\tvec3 opos = p+odir;\r\n"
"\t\t\r\n"
"\t\t\r\n"
"\t\tfor (int i=0; i<light_occlusion_iterations; i++)\r\n"
"\t\t{\r\n"
"\t\t\tfloat dd = dist(opos);\r\n"
"\t\t\tod = min(dd*2.0,od);\r\n"
"\t\t\t#ifdef high_precision_trace\r\n"
"\t\t\topos+=dd*odir*1.0;\r\n"
"\t\t\t#else\r\n"
"\t\t\topos+=dd*odir*2.0;\r\n"
"\t\t\t#endif\r\n"
"\t\t\tif (od<.02||opos.y>4.0) break;\r\n"
"\t\t}\r\n"
"\t\t\r\n"
"\t\t\r\n"
"\t\tod = max(od,.0);\r\n"
"\t\tvec3 n = normal(p);\r\n"
"\t\t\r\n"
"\t\tfloat diffuse = dot(n,light)*.8+.2; \r\n"
"\t\t\tdiffuse = pow(max(.0,diffuse*od),.7); \r\n"
"\t\t\tdiffuse = diffuse*.7 + .3;\r\n"
"\t\t\r\n"
"\t\tfloat ao = amb_occ(p)*.8+.2;\r\n"
"\t\t\t\r\n"
"\t\t\tfloat ao2 = dist(p+n)*1.0*.5+.4;\r\n"
"\t\t\r\n"
"\t\tif (terra(p).x<water(p).x)\r\n"
"\t\t{\r\n"
"\t\t\t\r\n"
"\t\t\tfloat shade = (dist(p-d)*.7+.3);\r\n"
"\t\t\t//float vertical = noise(p*vec3(2.5,14.5,2.5)).y*.5+.5;\r\n"
"\t\t\t\r\n"
"\t\t\tfloat top = max(.0,n.y);\r\n"
"\t\t\tn+=top*noise(p.xz*16.0)*.5;\r\n"
"\t\t\tn+=top*noise(p.xz*64.0)*.5;\r\n"
"\t\t\tn=normalize(n);\r\n"
"\t\t\ttop = max(.0,n.y);\r\n"
"\t\t\t\r\n"
"\t\t\tfloat specular  = pow(dot(reflect(d,n),light)*.5+.5,40.0)*od;\r\n"
"\t\t\t\r\n"
"\t\t\tc = mix(noise(p*vec3(.1,0.1,.1)),vec3(.6,.4,.2),.5+noise(p)*.6);\r\n"
"\t\t\tc = mix(c,texture2D(iChannel1,p.xz*.05).xyz,top);\r\n"
"\t\t\tc = mix(c,\r\n"
"\t\t\t\t\tmix(texture2D(iChannel1,p.xz*.75).xyz,texture2D(iChannel1,p.xz*.35).xyz,.5)\r\n"
"\t\t\t\t\t*vec3(.4,.6,.2),top*c.y);\r\n"
"\t\t\t \r\n"
"\t\t\tao2=min(ao2,1.0);\r\n"
"\t\t\t#ifdef shading_normal_only\r\n"
"\t\t\tc=n*.3+vec3(.3);\r\n"
"\t\t\t#else\r\n"
"\t\t\t#ifdef shading_light_occlusion_only\r\n"
"\t\t\tc=vec3(od*.35+.15);\r\n"
"\t\t\t#else\r\n"
"\t\t\t#ifdef shading_ambient_occlusion_only\r\n"
"\t\t\tc=vec3(ao*ao2*.5);\r\n"
"\t\t\t#else\r\n"
"\t\t\tc*=ao*ao2*diffuse;\r\n"
"\t\t\t#endif\r\n"
"\t\t\t#endif\r\n"
"\t\t\t#endif\r\n"
"\t\t}\r\n"
"\t\telse\r\n"
"\t\t{\r\n"
"\t\t\tfloat dterra = terra(p).x;\r\n"
"\t\t\tvec3 n = vec3(.0,1.0,.0);//*(sin(dterra*16.0)*.5/(1.0+dterra*4.0)+.5);\r\n"
"\t\t\tn+=(noise(p.xz*8.0+vec2(1.4,-1.3)*t)-.5)*.3;\r\n"
"\t\t\tn+=(noise(p.xz*16.0+vec2(-1.8,+1.5)*t)-.5)*.3;\r\n"
"\t\t\tn+=(noise(p.xz*32.0+vec2(1.7,1.5)*t)-.5)*.3;\r\n"
"\t\t\tn+=(noise(p.xz*256.0+vec2(-1.1,-1.2)*t)-.5)*.3;\r\n"
"\t\t\tn=normalize(n);\r\n"
"\t\t\t\r\n"
"\t\t\tfloat diffuse = dot(n,light)*.5+.5; \r\n"
"\t\t\tdiffuse = diffuse * od; \r\n"
"\t\t\tdiffuse = diffuse*.7 + .3;\r\n"
"\t\t\t\r\n"
"\t\t\tfloat or = 1.0;\r\n"
"\t\t\tvec3 odir = reflect(d,n);\r\n"
"\t\t\tvec3 opos = p+odir;\r\n"
"\t\t\t\r\n"
"\t\t\tfor (int i=0; i<relection_occlusion_iterations; i++)\r\n"
"\t\t\t{\r\n"
"\t\t\t\tfloat dd = dist(opos);\r\n"
"\t\t\t\tor = min(dd*1.0,or);\r\n"
"\t\t\t\t#ifdef high_precision_trace\r\n"
"\t\t\t\topos+=dd*odir*1.0;\r\n"
"\t\t\t\t#else\r\n"
"\t\t\t\topos+=dd*odir*8.0;\r\n"
"\t\t\t\t#endif\r\n"
"\t\t\t\tif (or<.02||opos.y>4.0) break;\r\n"
"\t\t\t}\r\n"
"\t\t\t\r\n"
"\t\t\tor = max(.0,or);\r\n"
"\t\t\tvec3 water_color = vec3(.1,.4,.3);\r\n"
"\t\t\twater_color = mix(vec3(.1,.4,.3)*.1,vec3(.3,.4,.4),1.0/(0.7+dterra));\r\n"
"\t\t\twater_color = mix(water_color,noise(p.xz*.2)*.4,.1);\r\n"
"\t\t\t\r\n"
"\t\t\tfloat specular = dot(reflect(d,n),light)*.5+.5;\r\n"
"\t\t\t//specular *= 1.0-cloud(reflect(d,n));\r\n"
"\t\t\t#ifdef shading_normal_only\r\n"
"\t\t\tc=n*.3+vec3(.3);\r\n"
"\t\t\t#else\r\n"
"\t\t\t#ifdef shading_light_occlusion_only\r\n"
"\t\t\tc=vec3(od*.35+.15);\r\n"
"\t\t\t#else\r\n"
"\t\t\t#ifdef shading_ambient_occlusion_only\r\n"
"\t\t\tc=vec3(ao*ao2*.5);\r\n"
"\t\t\t#else\r\n"
"\t\t\tc = (vec3(.0)\r\n"
"\t\t\t\t+ backdrop(n)*or \r\n"
"\t\t\t\t+ water_color*diffuse\r\n"
"\t\t\t\t+ vec3(pow(specular,4.0)*.3+pow(specular,40.0)*.5+pow(specular,180.0)*1.0)*or\r\n"
"\t\t\t\t)*ao*ao2;\r\n"
"\t\t\t\t;\r\n"
"\t\t\t#endif \r\n"
"\t\t\t#endif\r\n"
"\t\t\t#endif\r\n"
"\t\t}\r\n"
"\t\t//c=vec3(ao*ao2*.2+.4)*(od*.5+.5);\r\n"
"\t\t\r\n"
"\t}\r\n"
"\t\r\n"
"\tc = mix(c,air_color,acc);\r\n"
"\t\r\n"
"\tfloat of = 1.0;\r\n"
"\t\r\n"
"\t{\r\n"
"\t\tvec3 odir = light;\r\n"
"\t\tvec3 opos = start_pos;\r\n"
"\t\t\t\t\r\n"
"\t\tfor (int i=0; i<flare_occlusion_iterations; i++)\r\n"
"\t\t{\r\n"
"\t\t\tfloat dd = dist(opos);\r\n"
"\t\t\tof = min(dd*6.0+0.2,of);\r\n"
"\t\t\t#ifdef high_precision_trace\r\n"
"\t\t\topos+=dd*odir*1.0;\r\n"
"\t\t\t#else\r\n"
"\t\t\topos+=dd*odir*2.0;\r\n"
"\t\t\t#endif;\r\n"
"\t\t\tif (of<.02||opos.y>4.0) break;\r\n"
"\t\t}\r\n"
"\t}\r\n"
"\r\n"
"\tof = max(.0,of);\r\n"
"\t\r\n"
"\tvec3 projected_flare = (-light*inv_rotation);\r\n"
"\tif (projected_flare.z>.0)\r\n"
"\tc += max(vec3(.0),lensflare(uv*1.2,-projected_flare.xy/projected_flare.z*.6)*projected_flare.z*of);//*(1.0-cloud(light));\r\n"
"\t\r\n"
"\t//c = vec3(of);\r\n"
"\t\r\n"
"\tc*=1.0+1.0/(1.0+t*4.0);\r\n"
"\t\r\n"
"\tc-=length(uv)*.1;\r\n"
"\tc+=noise(vec3(uv*iResolution.y,iGlobalTime*60.0))*0.02;\r\n"
"\tc=mix(c,vec3(length(c)),length(c)*2.0-1.0);\r\n"
"\tc = max(vec3(.0),c);\r\n"
"\t\r\n"
"\tgl_FragColor = vec4(pow(c,vec3(1.0/1.8)),1.0);\r\n"
"\t\r\n"
"}"
};

const char *sample5={
"// Created by inigo quilez - iq/2013\r\n"
"// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\r\n"
"\r\n"
"vec2 monster( vec3 p )\r\n"
"{\r\n"
"\tp.x += 1.4*sin( 0.55*iGlobalTime + p.y );\r\n"
"\tp.z += 1.4*sin( 0.75*iGlobalTime + p.y );\r\n"
"\t\r\n"
"\tp.x += sin( 3.2*p.y + 0.0*iGlobalTime );\r\n"
"    p.z += sin( 2.0*p.x  + 3.0*p.y - 0.0*iGlobalTime );\r\n"
"\r\n"
"\tp.xz *= 3.0-0.25*(p.y+0.55);//1.5 - 1.0*sin(0.2*iGlobalTime);\r\n"
"\r\n"
"\r\n"
"\tp.y -= 0.4 + 5.0*sin(0.2*iGlobalTime);\r\n"
"\r\n"
"\tfloat r = 4.0 + 0.1*sin(10.0*p.y);\r\n"
"    vec2 d1 = vec2( length(p) - r, 1.0 );\r\n"
"\r\n"
"    return d1;\r\n"
"}\r\n"
"\r\n"
"\r\n"
"vec2 map( vec3 p )\r\n"
"{\r\n"
"    vec2 d2 = vec2( p.y+0.55, 2.0 );\r\n"
"\r\n"
"    vec2 d1 = monster( p );\r\n"
"\r\n"
"    if( d2.x<d1.x) d1=d2;\r\n"
"    return d1;\r\n"
"}\r\n"
"\r\n"
"\r\n"
"\r\n"
"vec2 intersect( in vec3 ro, in vec3 rd )\r\n"
"{\r\n"
"    float t=0.0;\r\n"
"    float dt = 0.08;\r\n"
"    float nh = 0.0;\r\n"
"    float lh = 0.0;\r\n"
"    float lm = -1.0;\r\n"
"    for(int i=0;i<100;i++)\r\n"
"    {\r\n"
"        vec2 ma = map(ro+rd*t);\r\n"
"        nh = ma.x;\r\n"
"        if(nh>0.0) { lh=nh; t+=dt;  } lm=ma.y;\r\n"
"    }\r\n"
"\r\n"
"    if( nh>0.0 ) return vec2(-1.0);\r\n"
"    t = t - dt*nh/(nh-lh);\r\n"
"\r\n"
"    return vec2(t,lm);\r\n"
"}\r\n"
"\r\n"
"float softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\r\n"
"{\r\n"
"    float res = 1.0;\r\n"
"    float dt = 0.1;\r\n"
"    float t = mint;\r\n"
"    for( int i=0; i<32; i++ )\r\n"
"    {\r\n"
"        float h = map(ro + rd*t).x;\r\n"
"        if( h>0.001 )\r\n"
"            res = min( res, k*h/t );\r\n"
"        else\r\n"
"            res = 0.0;\r\n"
"        t += dt;\r\n"
"    }\r\n"
"    return res;\r\n"
"}\r\n"
"\r\n"
"float occlusion( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\r\n"
"{\r\n"
"\t\r\n"
"\tfloat res = -1.0;\r\n"
"    float dt = 0.1;\r\n"
"    float t = 0.0;\r\n"
"\t\r\n"
"\tfloat ao = 0.0;\r\n"
"    for( int j=0; j<24; j++ )\r\n"
"\t{\r\n"
"\t\tres = -1.0;\r\n"
"     vec3 rr = normalize( vec3( -1.0+2.0*float(j)/32.0, 0.7, sin(1.2456*float(j)) ) );\r\n"
"\t\tt = 0.0;\r\n"
"\tfor( int i=0; i<10; i++ )\r\n"
"    {\r\n"
"        float h = monster(ro + rr*t).x;\r\n"
"        if( h<0.0 && res<0.0 )\r\n"
"\t\t{\r\n"
"            res = t;\r\n"
"\t\t}\r\n"
"        t += dt;\r\n"
"    }\r\n"
"\t\tif( res>0.0 ) ao += 1.0;\r\n"
"\t}\r\n"
"\r\n"
"\tres = 1.0-ao/24.0;\r\n"
"    return res;//*res;\r\n"
"}\r\n"
"\r\n"
"vec3 calcNormal( in vec3 pos )\r\n"
"{\r\n"
"    vec3  eps = vec3(.001,0.0,0.0);\r\n"
"    vec3 nor;\r\n"
"    nor.x = map(pos+eps.xyy).x - map(pos-eps.xyy).x;\r\n"
"    nor.y = map(pos+eps.yxy).x - map(pos-eps.yxy).x;\r\n"
"    nor.z = map(pos+eps.yyx).x - map(pos-eps.yyx).x;\r\n"
"    return normalize(nor);\r\n"
"}\r\n"
"\r\n"
"void main(void)\r\n"
"{\r\n"
"    vec2 q = gl_FragCoord.xy / iResolution.xy;\r\n"
"    vec2 p = -1.0 + 2.0 * q;\r\n"
"    p.x *= iResolution.x/iResolution.y;\r\n"
"\r\n"
"    // camera\r\n"
"    vec3 ro = vec3( 0.0, 0.8, 6.0 );\r\n"
"    vec3 ww = normalize(vec3(0.0,1.0,0.0) - ro);\r\n"
"    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\r\n"
"    vec3 vv = normalize(cross(ww,uu));\r\n"
"    vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\r\n"
"\r\n"
"    vec3 col = texture2D( iChannel0, q*vec2(1.0,-1.0) ).xyz;\r\n"
"\r\n"
"    // raymarch\r\n"
"    vec2 tmat = intersect(ro,rd);\r\n"
"    if( tmat.y>0.5 )\r\n"
"    {\r\n"
"        // geometry\r\n"
"        vec3 pos = ro + tmat.x*rd;\r\n"
"        vec3 nor = calcNormal(pos);\r\n"
"        vec3 ref = reflect(rd,nor);\r\n"
"        vec3 lig = normalize(vec3(0.2,0.8,0.1));\r\n"
"     \r\n"
"        float con = 1.0;\r\n"
"        float amb = 0.5 + 0.5*nor.y;\r\n"
"        float dif = max(dot(nor,lig),0.0);\r\n"
"        float bac = max(0.2 + 0.8*dot(nor,vec3(-lig.x,lig.y,-lig.z)),0.0);\r\n"
"        float rim = pow(1.0+dot(nor,rd),1.0);\r\n"
"\r\n"
"        // shadow\r\n"
"        float sh = softshadow( pos, lig, 0.06, 4.0, 4.0 );\r\n"
"\r\n"
"        // lights\r\n"
"\r\n"
"\r\n"
"        // color\r\n"
"        vec2 pro;\r\n"
"        if( tmat.y<1.5 )\r\n"
"\t\t{\r\n"
"        col  = 0.10*con*vec3(0.90,0.90,0.90);\r\n"
"        col += 0.30*dif*vec3(1.00,0.97,0.85)*vec3(sh, (sh+sh*sh)*0.5, sh*sh );\r\n"
"        col += 0.20*bac*vec3(1.00,0.90,0.90);\r\n"
"        col += 0.20*amb*vec3(0.20,0.22,0.25);\r\n"
"\r\n"
"\t\tvec3 mcol = texture2D( iChannel0, 0.5 + 0.5*nor.xy*vec2(-1.0,-1.0) + 0.5*pos.xy ).xyz;\r\n"
"\t\t//mcol = mix( mcol*1.5, vec3(0.0,1.0,1.0), pow(1.0-rim,1.0) );\r\n"
"\t\t//mcol = vec3(1.3,1.0,0.7);\r\n"
"        col *= 1.5*mcol;\r\n"
"\t\t\t\r\n"
"\t\t\tcol *= 0.4+0.6*smoothstep( -0.5, -0.15, pos.y );\r\n"
"\t\t\t\r\n"
"        // rim and spec\r\n"
"        //col += 0.60*rim*vec3(1.0,0.97,0.85)*amb*amb;\r\n"
"\r\n"
"        col = 0.3*col + 0.7*sqrt(col);\r\n"
"\t\t}\r\n"
"        else\r\n"
"\t\t{\r\n"
"           col *= 0.35 + 0.65*sh;\r\n"
"\r\n"
"\t\tfloat f = occlusion( pos, vec3(0.0,1.0,0.0), 0.06, 4.0, 4.0 ); \r\n"
"\t\tcol *= vec3(f);\r\n"
"\r\n"
"\t\t}\r\n"
"\r\n"
"\r\n"
"    }\r\n"
"\r\n"
"\tcol *= vec3( 1.0, 1.05, 1.0 );\r\n"
"    col *= 0.25 + 0.75*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.15 );\r\n"
"\r\n"
"    gl_FragColor = vec4(col,1.0);\r\n"
"}"
};

const char *sample6={
"// srtuss, 2013\r\n"
"\r\n"
"// collecting some design ideas for a new game project.\r\n"
"// no raymarching is used.\r\n"
"\r\n"
"// if i could add a custom soundtrack, it'd use this one (essential for desired sensation)\r\n"
"// http://www.youtube.com/watch?v=1uFAu65tZpo\r\n"
"\r\n"
"\r\n"
"//#define GREEN_VERSION\r\n"
"\r\n"
"// ** improved camera shaking\r\n"
"// ** cleaned up code\r\n"
"// ** added stuff to the gates\r\n"
"\r\n"
"\r\n"
"\r\n"
"float time = iGlobalTime;\r\n"
"\r\n"
"vec2 rotate(vec2 p, float a)\r\n"
"{\r\n"
"\treturn vec2(p.x * cos(a) - p.y * sin(a), p.x * sin(a) + p.y * cos(a));\r\n"
"}\r\n"
"float box(vec2 p, vec2 b, float r)\r\n"
"{\r\n"
"\treturn length(max(abs(p) - b, 0.0)) - r;\r\n"
"}\r\n"
"\r\n"
"// iq's ray-plane-intersection code\r\n"
"vec3 intersect(in vec3 o, in vec3 d, vec3 c, vec3 u, vec3 v)\r\n"
"{\r\n"
"\tvec3 q = o - c;\r\n"
"\treturn vec3(\r\n"
"\t\tdot(cross(u, v), q),\r\n"
"\t\tdot(cross(q, u), d),\r\n"
"\t\tdot(cross(v, q), d)) / dot(cross(v, u), d);\r\n"
"}\r\n"
"\r\n"
"// some noise functions for fast developing\r\n"
"float rand11(float p)\r\n"
"{\r\n"
"    return fract(sin(p * 591.32) * 43758.5357);\r\n"
"}\r\n"
"float rand12(vec2 p)\r\n"
"{\r\n"
"    return fract(sin(dot(p.xy, vec2(12.9898, 78.233))) * 43758.5357);\r\n"
"}\r\n"
"vec2 rand21(float p)\r\n"
"{\r\n"
"\treturn fract(vec2(sin(p * 591.32), cos(p * 391.32)));\r\n"
"}\r\n"
"vec2 rand22(in vec2 p)\r\n"
"{\r\n"
"\treturn fract(vec2(sin(p.x * 591.32 + p.y * 154.077), cos(p.x * 391.32 + p.y * 49.077)));\r\n"
"}\r\n"
"\r\n"
"float noise11(float p)\r\n"
"{\r\n"
"\tfloat fl = floor(p);\r\n"
"\treturn mix(rand11(fl), rand11(fl + 1.0), fract(p));//smoothstep(0.0, 1.0, fract(p)));\r\n"
"}\r\n"
"float fbm11(float p)\r\n"
"{\r\n"
"\treturn noise11(p) * 0.5 + noise11(p * 2.0) * 0.25 + noise11(p * 5.0) * 0.125;\r\n"
"}\r\n"
"vec3 noise31(float p)\r\n"
"{\r\n"
"\treturn vec3(noise11(p), noise11(p + 18.952), noise11(p - 11.372)) * 2.0 - 1.0;\r\n"
"}\r\n"
"\r\n"
"// something that looks a bit like godrays coming from the surface\r\n"
"float sky(vec3 p)\r\n"
"{\r\n"
"\tfloat a = atan(p.x, p.z);\r\n"
"\tfloat t = time * 0.1;\r\n"
"\tfloat v = rand11(floor(a * 4.0 + t)) * 0.5 + rand11(floor(a * 8.0 - t)) * 0.25 + rand11(floor(a * 16.0 + t)) * 0.125;\r\n"
"\treturn v;\r\n"
"}\r\n"
"\r\n"
"vec3 voronoi(in vec2 x)\r\n"
"{\r\n"
"\tvec2 n = floor(x); // grid cell id\r\n"
"\tvec2 f = fract(x); // grid internal position\r\n"
"\tvec2 mg; // shortest distance...\r\n"
"\tvec2 mr; // ..and second shortest distance\r\n"
"\tfloat md = 8.0, md2 = 8.0;\r\n"
"\tfor(int j = -1; j <= 1; j ++)\r\n"
"\t{\r\n"
"\t\tfor(int i = -1; i <= 1; i ++)\r\n"
"\t\t{\r\n"
"\t\t\tvec2 g = vec2(float(i), float(j)); // cell id\r\n"
"\t\t\tvec2 o = rand22(n + g); // offset to edge point\r\n"
"\t\t\tvec2 r = g + o - f;\r\n"
"\t\t\t\r\n"
"\t\t\tfloat d = max(abs(r.x), abs(r.y)); // distance to the edge\r\n"
"\t\t\t\r\n"
"\t\t\tif(d < md)\r\n"
"\t\t\t\t{md2 = md; md = d; mr = r; mg = g;}\r\n"
"\t\t\telse if(d < md2)\r\n"
"\t\t\t\t{md2 = d;}\r\n"
"\t\t}\r\n"
"\t}\r\n"
"\treturn vec3(n + mg, md2 - md);\r\n"
"}\r\n"
"\r\n"
"#define A2V(a) vec2(sin((a) * 6.28318531 / 100.0), cos((a) * 6.28318531 / 100.0))\r\n"
"\r\n"
"float circles(vec2 p)\r\n"
"{\r\n"
"\tfloat v, w, l, c;\r\n"
"\tvec2 pp;\r\n"
"\tl = length(p);\r\n"
"\t\r\n"
"\t\r\n"
"\tpp = rotate(p, time * 3.0);\r\n"
"\tc = max(dot(pp, normalize(vec2(-0.2, 0.5))), -dot(pp, normalize(vec2(0.2, 0.5))));\r\n"
"\tc = min(c, max(dot(pp, normalize(vec2(0.5, -0.5))), -dot(pp, normalize(vec2(0.2, -0.5)))));\r\n"
"\tc = min(c, max(dot(pp, normalize(vec2(0.3, 0.5))), -dot(pp, normalize(vec2(0.2, 0.5)))));\r\n"
"\t\r\n"
"\t// innerest stuff\r\n"
"\tv = abs(l - 0.5) - 0.03;\r\n"
"\tv = max(v, -c);\r\n"
"\tv = min(v, abs(l - 0.54) - 0.02);\r\n"
"\tv = min(v, abs(l - 0.64) - 0.05);\r\n"
"\t\r\n"
"\tpp = rotate(p, time * -1.333);\r\n"
"\tc = max(dot(pp, A2V(-5.0)), -dot(pp, A2V(5.0)));\r\n"
"\tc = min(c, max(dot(pp, A2V(25.0 - 5.0)), -dot(pp, A2V(25.0 + 5.0))));\r\n"
"\tc = min(c, max(dot(pp, A2V(50.0 - 5.0)), -dot(pp, A2V(50.0 + 5.0))));\r\n"
"\tc = min(c, max(dot(pp, A2V(75.0 - 5.0)), -dot(pp, A2V(75.0 + 5.0))));\r\n"
"\t\r\n"
"\tw = abs(l - 0.83) - 0.09;\r\n"
"\tv = min(v, max(w, c));\r\n"
"\t\r\n"
"\treturn v;\r\n"
"}\r\n"
"\r\n"
"float shade1(float d)\r\n"
"{\r\n"
"\tfloat v = 1.0 - smoothstep(0.0, mix(0.012, 0.2, 0.0), d);\r\n"
"\tfloat g = exp(d * -20.0);\r\n"
"\treturn v + g * 0.5;\r\n"
"}\r\n"
"\r\n"
"void main(void)\r\n"
"{\r\n"
"\tvec2 uv = gl_FragCoord.xy / iResolution.xy;\r\n"
"\tuv = uv * 2.0 - 1.0;\r\n"
"\tuv.x *= iResolution.x / iResolution.y;\r\n"
"\t\r\n"
"\t\r\n"
"\t// using an iq styled camera this time :)\r\n"
"\t// ray origin\r\n"
"\tvec3 ro = 0.7 * vec3(cos(0.2 * time), 0.0, sin(0.2 * time));\r\n"
"\tro.y = cos(0.6 * time) * 0.3 + 0.65;\r\n"
"\t// camera look at\r\n"
"\tvec3 ta = vec3(0.0, 0.2, 0.0);\r\n"
"\t\r\n"
"\t// camera shake intensity\r\n"
"\tfloat shake = clamp(3.0 * (1.0 - length(ro.yz)), 0.3, 1.0);\r\n"
"\tfloat st = mod(time, 10.0) * 143.0;\r\n"
"\t\r\n"
"\t// build camera matrix\r\n"
"\tvec3 ww = normalize(ta - ro + noise31(st) * shake * 0.01);\r\n"
"\tvec3 uu = normalize(cross(ww, normalize(vec3(0.0, 1.0, 0.2 * sin(time)))));\r\n"
"\tvec3 vv = normalize(cross(uu, ww));\r\n"
"\t// obtain ray direction\r\n"
"\tvec3 rd = normalize(uv.x * uu + uv.y * vv + 1.0 * ww);\r\n"
"\t\r\n"
"\t// shaking and movement\r\n"
"\tro += noise31(-st) * shake * 0.015;\r\n"
"\tro.x += time * 2.0;\r\n"
"\t\r\n"
"\tfloat inten = 0.0;\r\n"
"\t\r\n"
"\t// background\r\n"
"\tfloat sd = dot(rd, vec3(0.0, 1.0, 0.0));\r\n"
"\tinten = pow(1.0 - abs(sd), 20.0) + pow(sky(rd), 5.0) * step(0.0, rd.y) * 0.2;\r\n"
"\t\r\n"
"\tvec3 its;\r\n"
"\tfloat v, g;\r\n"
"\t\r\n"
"\t// voronoi floor layers\r\n"
"\tfor(int i = 0; i < 4; i ++)\r\n"
"\t{\r\n"
"\t\tfloat layer = float(i);\r\n"
"\t\tits = intersect(ro, rd, vec3(0.0, -5.0 - layer * 5.0, 0.0), vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0));\r\n"
"\t\tif(its.x > 0.0)\r\n"
"\t\t{\r\n"
"\t\t\tvec3 vo = voronoi((its.yz) * 0.05 + 8.0 * rand21(float(i)));\r\n"
"\t\t\tv = exp(-100.0 * (vo.z - 0.02));\r\n"
"\t\t\t\r\n"
"\t\t\tfloat fx = 0.0;\r\n"
"\t\t\t\r\n"
"\t\t\t// add some special fx to lowest layer\r\n"
"\t\t\tif(i == 3)\r\n"
"\t\t\t{\r\n"
"\t\t\t\tfloat crd = 0.0;//fract(time * 0.2) * 50.0 - 25.0;\r\n"
"\t\t\t\tfloat fxi = cos(vo.x * 0.2 + time * 1.5);//abs(crd - vo.x);\r\n"
"\t\t\t\tfx = clamp(smoothstep(0.9, 1.0, fxi), 0.0, 0.9) * 1.0 * rand12(vo.xy);\r\n"
"\t\t\t\tfx *= exp(-3.0 * vo.z) * 2.0;\r\n"
"\t\t\t}\r\n"
"\t\t\tinten += v * 0.1 + fx;\r\n"
"\t\t}\r\n"
"\t}\r\n"
"\t\r\n"
"\t// draw the gates, 4 should be enough\r\n"
"\tfloat gatex = floor(ro.x / 8.0 + 0.5) * 8.0 + 4.0;\r\n"
"\tfloat go = -16.0;\r\n"
"\tfor(int i = 0; i < 4; i ++)\r\n"
"\t{\r\n"
"\t\tits = intersect(ro, rd, vec3(gatex + go, 0.0, 0.0), vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 1.0));\r\n"
"\t\tif(dot(its.yz, its.yz) < 2.0 && its.x > 0.0)\r\n"
"\t\t{\r\n"
"\t\t\tv = circles(its.yz);\r\n"
"\t\t\tinten += shade1(v);\r\n"
"\t\t}\r\n"
"\t\t\r\n"
"\t\tgo += 8.0;\r\n"
"\t}\r\n"
"\t\r\n"
"\t// draw the stream\r\n"
"\tfor(int j = 0; j < 20; j ++)\r\n"
"\t{\r\n"
"\t\tfloat id = float(j);\r\n"
"\t\t\r\n"
"\t\tvec3 bp = vec3(0.0, (rand11(id) * 2.0 - 1.0) * 0.25, 0.0);\r\n"
"\t\tvec3 its = intersect(ro, rd, bp, vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0));\r\n"
"\t\t\r\n"
"\t\tif(its.x > 0.0)\r\n"
"\t\t{\r\n"
"\t\t\tvec2 pp = its.yz;\r\n"
"\t\t\tfloat spd = (1.0 + rand11(id) * 3.0) * 2.5;\r\n"
"\t\t\tpp.y += time * spd;\r\n"
"\t\t\tpp += (rand21(id) * 2.0 - 1.0) * vec2(0.3, 1.0);\r\n"
"\t\t\tfloat rep = rand11(id) + 1.5;\r\n"
"\t\t\tpp.y = mod(pp.y, rep * 2.0) - rep;\r\n"
"\t\t\tfloat d = box(pp, vec2(0.02, 0.3), 0.1);\r\n"
"\t\t\tfloat foc = 0.0;\r\n"
"\t\t\tfloat v = 1.0 - smoothstep(0.0, 0.03, abs(d) - 0.001);\r\n"
"\t\t\tfloat g = min(exp(d * -20.0), 2.0);\r\n"
"\t\t\t\r\n"
"\t\t\tinten += (v + g * 0.7) * 0.5;\r\n"
"\t\t\t\r\n"
"\t\t}\r\n"
"\t}\r\n"
"\t\r\n"
"\tinten *= 0.4 + (sin(time) * 0.5 + 0.5) * 0.6;\r\n"
"\t\r\n"
"\t// find a color for the computed intensity\r\n"
"#ifdef GREEN_VERSION\r\n"
"\tvec3 col = pow(vec3(inten), vec3(2.0, 0.15, 9.0));\r\n"
"#else\r\n"
"\tvec3 col = pow(vec3(inten), 1.5 * vec3(0.15, 2.0, 9.0));\r\n"
"#endif\r\n"
"\t\r\n"
"\tgl_FragColor = vec4(col, 1.0);\r\n"
"}"
};
const char *sample7={
"//\"Glass Field\" by Kali\r\n"
"\r\n"
"#define lightcol1 vec3(1.,.95,.85)\r\n"
"#define lightcol2 vec3(.85,.95,1.)\r\n"
"\r\n"
"\r\n"
"\r\n"
"\r\n"
"//Rotation matrix by Syntopia\r\n"
"mat3 rotmat(vec3 v, float angle)\r\n"
"{\r\n"
"\tfloat c = cos(angle);\r\n"
"\tfloat s = sin(angle);\r\n"
"\t\r\n"
"\treturn mat3(c + (1.0 - c) * v.x * v.x, (1.0 - c) * v.x * v.y - s * v.z, (1.0 - c) * v.x * v.z + s * v.y,\r\n"
"\t\t(1.0 - c) * v.x * v.y + s * v.z, c + (1.0 - c) * v.y * v.y, (1.0 - c) * v.y * v.z - s * v.x,\r\n"
"\t\t(1.0 - c) * v.x * v.z - s * v.y, (1.0 - c) * v.y * v.z + s * v.x, c + (1.0 - c) * v.z * v.z\r\n"
"\t\t);\r\n"
"}\r\n"
"\r\n"
"//Smooth min by IQ\r\n"
"float smin( float a, float b )\r\n"
"{\r\n"
"    float k = 0.5;\r\n"
"\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\r\n"
"\treturn mix( b, a, h ) - k*h*(1.0-h);\r\n"
"}\r\n"
"\r\n"
"\r\n"
"//Distance Field\r\n"
"float de(vec3 pos) {\r\n"
"\tvec3 A=vec3(5.);\r\n"
"\tvec3 p = abs(A-mod(pos,2.0*A)); //tiling fold by Syntopia\r\n"
"\tfloat sph=length(p)-2.5;\r\n"
"\tfloat cyl=length(p.xy)-.4;\r\n"
"\tcyl=min(cyl,length(p.xz))-.4;\r\n"
"\tcyl=min(cyl,length(p.yz))-.4;\r\n"
"    return smin(cyl,sph);\r\n"
"}\r\n"
"\r\n"
"// finite difference normal\r\n"
"vec3 normal(vec3 pos) {\r\n"
"\tvec3 e = vec3(0.0,0.001,0.0);\r\n"
"\t\r\n"
"\treturn normalize(vec3(\r\n"
"\t\t\tde(pos+e.yxx)-de(pos-e.yxx),\r\n"
"\t\t\tde(pos+e.xyx)-de(pos-e.xyx),\r\n"
"\t\t\tde(pos+e.xxy)-de(pos-e.xxy)\r\n"
"\t\t\t)\r\n"
"\t\t);\t\r\n"
"}\r\n"
"\r\n"
"\r\n"
"void main(void)\r\n"
"{\r\n"
"\tfloat time = iGlobalTime*.6; \r\n"
"\r\n"
"\t//camera\r\n"
"\tmat3 rotview=rotmat(normalize(vec3(1.)),sin(time*.6));\r\n"
"\tvec2 coord = gl_FragCoord.xy / iResolution.xy *2. - vec2(1.);\r\n"
"\tcoord.y *= iResolution.y / iResolution.x;\r\n"
"\tfloat fov=min((time*.2+.05),0.8); //animate fov at start\r\n"
"\tvec3 from = vec3(cos(time)*2.,sin(time*.5)*10.,time*5.);\r\n"
"\r\n"
"\t//raymarch\r\n"
"\tfloat totdist=0.;\r\n"
"\tfloat distfade=1.;\r\n"
"\tfloat glassfade=1.;\r\n"
"\tfloat intens=1.;\r\n"
"\tfloat maxdist=80.;\r\n"
"\tfloat vol=0.;\r\n"
"\tvec3 spec=vec3(0.);\r\n"
"\tvec3 dir=normalize(vec3(coord.xy*fov,1.))*rotview; \r\n"
"\tfloat ref=0.;\r\n"
"\tvec3 light1=normalize(vec3(cos(time),sin(time*3.)*.5,sin(time)));\r\n"
"\tvec3 light2=normalize(vec3(cos(time),sin(time*3.)*.5,-sin(time)));\r\n"
"\tfor (int r=0; r<80; r++) {\r\n"
"\t\tvec3 p=from+totdist*dir;\r\n"
"\t\tfloat d=de(p);\r\n"
"\t\tfloat distfade=exp(-1.5*pow(totdist/maxdist,1.5));\r\n"
"\t\tintens=min(distfade,glassfade);\r\n"
"\r\n"
"\t\t// refraction\r\n"
"\t\tif (d>0.0 && ref>.5) {\r\n"
"\t\t\tref=0.;\r\n"
"\t\t\tvec3 n=normal(p);\r\n"
"\t\t\tif (dot(dir,n)<-.5) dir=normalize(refract(dir,n,1./.87));\r\n"
"\t\t\tvec3 refl=reflect(dir,n);\r\n"
"\t\t\tspec+=lightcol1*pow(max(dot(refl,light1),0.0),40.)*intens*.7;\r\n"
"\t\t\tspec+=lightcol2*pow(max(dot(refl,light2),0.0),40.)*intens*.7;\r\n"
"\r\n"
"\t\t}\r\n"
"\t\tif (d<0.0 && ref<.05) {\r\n"
"\t\t\tref=1.;\r\n"
"\t\t\tvec3 n=normal(p);\r\n"
"\t\t\tif (dot(dir,n)<-.05) dir=normalize(refract(dir,n,.87));\r\n"
"\t\t\tvec3 refl=reflect(dir,n);\r\n"
"\t\t\tglassfade*=.75;\r\n"
"\t\t\tspec+=lightcol1*pow(max(dot(refl,light1),0.0),40.)*intens;\r\n"
"\t\t\tspec+=lightcol2*pow(max(dot(refl,light2),0.0),40.)*intens;\r\n"
"\t\t}\r\n"
"\t\t\r\n"
"\t\ttotdist+=max(0.005,abs(d)); //advance ray \r\n"
"\t\tif (totdist>maxdist) break; \r\n"
"\r\n"
"\t\tvol+=intens; //accumulate current intensity\r\n"
"\t}\r\n"
"\t\r\n"
"\tvol=pow(vol,1.5)*.0005;\r\n"
"\tvec3 col=vec3(vol)+vec3(spec)*.4+vec3(.05);\r\n"
"\r\n"
"\t//lights\r\n"
"\tcol+=1.5*lightcol1*pow(max(0.,max(0.,dot(dir,light1))),10.)*glassfade; \r\n"
"\tcol+=1.5*lightcol2*pow(max(0.,max(0.,dot(dir,light2))),10.)*glassfade; \r\n"
"\t//col+=vec3(sin(time*10.)+1.,0.,0.)*.8*pow(max(0.,max(0.,dot(dir,vec3(0.,0.,1.)))),5.)*glassfade; \r\n"
"\r\n"
"\t\r\n"
"\tcol*=min(1.,time); //fade in\r\n"
"\r\n"
"\tgl_FragColor = vec4(col,1.0);\t\r\n"
"}"
};